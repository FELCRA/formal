<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN' 'http://www.w3.org/TR/html4/loose.dtd'>
<html>
   <head>
   <title>
prelude
</title>
   
<link rel='stylesheet' type='text/css' href='lib/js/jasmine-1.0.1/jasmine.css'>
<script type='text/javascript' src='lib/js/jasmine-1.0.1/jasmine.js'></script>
   <script type='text/javascript' src='lib/js/jasmine-1.0.1/jasmine-html.js'></script>
   <script type='text/javascript' src='lib/js/zepto.js'></script>
   <script type='text/javascript' src='prelude.js'></script>
   <script type='text/javascript' src='prelude.spec.js'></script>
   
<link href='http://kevinburke.bitbucket.org/markdowncss/markdown.css' rel='stylesheet'></link> <link href='lib/js/prettify.css' type='text/css' rel='stylesheet' />
<script type='text/javascript' src='lib/js/prettify.js'></script>
   <script type='text/javascript' src='lib/js/lang-hs.js'></script>
   <script type='text/javascript' src='lib/js/jquery.js'></script>
   <style>ul{padding-left:40px;}</style>
   </head>
   <body>
   <div style='margin: 0 0 50px 0'>
<h1 id="sonnet">Sonnet</h1>
<p>A programming language, designed to be read</p>
<hr />
<p>Sonnet is:</p>
<ul>
<li>functional, pure, statically type inferred, eagerly evaluated</li>
<li>flexible syntax that's simple and easy on the eyes</li>
<li>targets V8 Javascript (Chrome &amp; Node.js), Closure Advanced</li>
<li>first class syntax for Javascript, JSON &amp; HTML</li>
<li>first class syntax for assertions &amp; invariant style testing ala QuickCheck, compiler by default generate Jasmine suite</li>
<li>standard lib for events, lazy sequences &amp; comprehensions</li>
<li>directly inspired by Haskell, F#, OCAML, Coffeescript, Clojure, Scala</li>
</ul>
<h2 id="values-and-types">Values and Types</h2>
<p>Anonymous JSON:</p>
<pre><code>type Unit = {}   

type Complex = { real: Num, img: Num }</code></pre>
<p>Named JSON - this is basically a special function that takes an anonymous JSON as an argument and returns the same value of a new type, with the option of ignoring the <code>{}</code> in such values which take a <code>Unit</code> type as an argument.</p>
<pre><code>type Point = point: { x: Num, y: Num }

type Unitt = unit: {}  </code></pre>
<p>Union JSON - which is simply a set of any of the above or of the native JSON types, separated by either new lines w/indentation, or <code>|</code></p>
<pre><code>type Option a = some: a | none: {}

type Bool = true: | false:</code></pre>
<p>Polymorphic JSON, which are any of the above with an introduction of a some type variables into scope:</p>
<pre><code>type List a = 
    | { head: a, tail: List a }
    | nil:

type Map key value =
    | from_list: { items: List (T key value) }
    | empty:

mult { x: real, y: img } { u: real, v: img } = 
     { real: x * u - y * v, img: x * v - y * u }  

-- Alternatively:
mult x y = { real: x.real * y.real - x.img * y.img
             img:  x.real * y.img - x.img * y.real }</code></pre>
<p>Inherited JSON, which is polymorphic to the type it inherits from, and is declared using the <code>with</code> keyword:</p>
<pre><code>type Semigroup a = { zero: a }

type Monoid a = { Semigroup with plus: a &#8594; a &#8594; a }</code></pre>
<h2 id="definitions">Definitions</h2>
<p>Modules define a scope for a collection of definitions, including other modules. While one need not indent the contents of a module, sequential module definitions in a file will be considered nested unless explicitly sequential via indentation.</p>
<pre><code>module list

import seq
import webgl</code></pre>
<p>Definitions themselves are somposed of a name, and a collection of cases, optionally prefaced by a type annotation. The syntax itself is designed to be flexible to facilitate readable code for definitions of all shapes and sizes, but in general is designed to emulate a tabular layout. For example, one could write a simple head function in several different ways:</p>
<pre><code>-- destructured, tabular
head: List a             &#8594; a
    | cons: { head = x } = x
    | nil:               = undefined -- head is not defined for an empty list.   

-- via record accessors
head&#39; (cons: x) = x.head | nil: = undefined

-- anonymous function
head&#39;&#39; = \ (cons:{head:x}) = x
         | _ = undefined



tail:
-- This is an embellished, overly readable version of tail, designed
-- to illustrate a long-form way of writing definitions in Sonnet. 

      List a    &#8594; a
    | (cons: x) = x.tail
    | []        = undefined 

    -- Unit tests

    tail [3] == 3
    tail [5, 1, 2] == [1, 2]



--- Applies f recursively from the last element of the list.  Consumes 
--  much stack

foldr:  (a &#8594; b &#8594; a) &#8594; b &#8594; List a &#8594; b
| f x [] = x
| f x (cons-&gt;{head=y,tail=ys}) = f y (foldr f x ys) 

length:
--- Returns the cardinality of a list

    List a    &#8594; Int
  | []        = 0
  | [_, xs] = 1 + length xs

length [] == 0
length [1] == 1
length [1, 3, 2, 4] == 4</code></pre>
<p>Though comments are defined via --, the alternative --- defines metadata in the form of a string which applies to the previous symbol. The use of undefined above logs its metadata when it is evaluated, and provides documentation for the function itself.</p>
<p>Anonymous functions may be declared with <code>&#955;</code> in two different forms, via pattern match (haskell-style) or via variable &quot;templating&quot; (clojure style):</p>
<pre><code>tail = &#955; (cons -&gt; {tail = y}) = y
       | []      = undefined</code></pre>
<p>or via variable &quot;templating&quot; (clojure style):</p>
<pre><code>--fmap (&#955;_ + 1) [1 2 3] ? [2 3 4] </code></pre>
<h2 id="assertions">Assertions</h2>
<p>Assertions can be declared simply by writing an expression which evaluates to a boolean. Assertions are compiled to a seperate file (____.tests.js), but included in the genreated documentation, such that loading the documentation (_____.html) runs the test suite and prints the results at the bottom.</p>
<pre><code>filter: (a -&gt; bool) -&gt; List a -&gt; List a
      | f [] = []
      | f (cons-&gt;{head=x,tail=xs}) = append (f x) (filter f xs)

filter (\x = x &lt; 2) [0, 1, 3, 4, 1, 4] == [0, 1, 1]</code></pre>
<h2 id="patterns">Patterns</h2>
<pre><code>type ReverseList a = reverse_list: List a

reverse (cons -&gt; {head=x,tail=xs}) = reverse xs + x | [] = []

last: List a            &#8594; a
    | (reverse -&gt; (cons -&gt; {head=x})) = x
    | _ = undefined

type Parity = even: | odd:

length_parity (cons -&gt; {tail=(length_parity -&gt; even)}) = odd | _ = even    

length_parityy (cons -&gt; {tail=xs}) = ap (length_parity xs) (\ even: = odd: | _ = even:)</code></pre>
<h2 id="implicits">Implicits</h2>
<p>Any definition may be marked as implicit, which simply means that if the type checker fails, the compiler will attempt to &quot;fill in&quot; parameters marked implicit with a unique instance in scope. For example, Haskell's Show type class can be easily implemented as a function with an implicit return type:</p>
<pre><code>____: 

    Complex          -&gt; Str
  | x when x.img == 0 = string x.real
  | x when x.img &gt; 0  = string x.real + &quot; + &quot; + x.img + &quot;i&quot;
  | x                 = string x.real + &quot; - &quot; + x.img + &quot;i&quot;</code></pre>
<p>The <code>___</code> makes this function implicit; it is by extension uninvokable by name. As there is now a unique implicit instance of a function which converts <code>Complex</code> to <code>Str</code>, we may now use <code>Complex</code> types in places where we would otherwise use a string:</p>
<pre><code>length { real = 2.0, img = 3.0 } == 10</code></pre>
<p>Implicit parameters other than the return type may be optionally left out of the function invocation - as long as there is a unique instance in scope which satisfies the type signature, it will be inserted automatically.</p>
<pre><code>type Class a = (a -&gt; b) -&gt; b

___ : (class: a) -&gt; Class a 
    | x             f = f x

type Functor f = { map: (a -&gt; b) -&gt; f a -&gt; f b }

___: Class (Functor List) = class:

     { map = \ f (cons-&gt;{head=x,tail=xs}) = append [f x] (mapp f xs)
             | f [] = [] }

map | f = f.map

incF: (class: Functor f) -&gt; f Int &#8594; f Int
    | functor                 g   = functor.map inc m

fmap func (comp f g) x == fmap func f (fmap func g x)
fmap func id x == x</code></pre>
<p>There is a single instance of Functor List in scope (even though it has no name), so fmap can be invoked on lists with no Functor param</p>
<pre><code>fmap (\ x = x + 1) [1, 2, 3] == [2, 3, 4]    </code></pre>
<p>Here's a few sample Haskell type classes encoded as regular ADTs, then instantiated such that they may be useful as implicit parameters:</p>
<pre><code>type Applicative f =

    { Functor f with
          return: a -&gt; f a,
          ap:    f (a &#8594; b) &#8594; f a &#8594; f b }

f | x = x ** 1

applicative = abstract: { map f x = return f * x }  </code></pre>
<p>-- forall u v w x y</p>
<pre><code>    return id * v == v f                        -- Identity
    return comp ** u ** v ** w == u ** (v ** w) -- Composition
    return f ** return x == return (f x)       -- Homomorphism
    u ** return y == return (\ f = f y) ** u       -- Interchange      

type Monad m =

    { Applicative m with
          bind: m a &#8594; (a &#8594; m b) &#8594; m b,
          join: m (m a) &#8594; m a }

monad = abstract:

    { applicative with
          ap x y = x &gt;&gt;= (\ f = map f y)
          bind x y = join (map f x)
          join x = x &gt;&gt;= id }

return x &gt;&gt;= f == f x                   -- Left identity
x &gt;&gt;= return == x                       -- Right identity              
(f &gt;&gt;= g) &gt;&gt;= h == f &gt;&gt;= (\ x = g x &gt;&gt;= h)  -- Commutatative </code></pre>
<p>Since the type of this instance is inferable and we aren't naming it, we can declare instance simply like this:</p>
<pre><code>{ zero = []

  plus (cons: {h=x,t=y}) = x ++ (y + z)
     | []                = x }

zero + [1] + zero == [1]
[2 3] + zero + [1] == [2 3 1]</code></pre>
<p>Though in some cases, we may want to give it a name and or type annotation:</p>
<pre><code>list_monad =

    { monad with 
          return x = [x]
          bind xs f = reduce (\ x y = x + y) (map f y)
          bind [] f = zero }

map list_monad fib [] == zero
map list_monad fib [0 1] == [1 1]
map list_monad fib [6] == [13]
map list_monad fib [2 3 4 5] == [1 2 3 5]</code></pre>
<h2 id="javascript-html">Javascript &amp; HTML</h2>
<p>Sonnet's standard IO library covers many common browser &amp; node.js libraries, but the language itself has no support for IO per se. Rather, side effects are only allowed to occur in quoted javascript, which has slightly different rules than standard javascript, but compiles into basically what you expect.</p>
<pre><code>log: Str &#8594; !
   | x = `console.log(x)`</code></pre>
<p>The return type of any quoted javascript is a special IO type <code>a!</code>, where a is inferred to be <code>()</code> when not provided.</p>
<pre><code>io_monad: Monad String
    | = { return x = `function() { return x }`
          bind x f  =  `f(x())` }

module jquery
--  Library of useful JQuery wrappers

    --  Sets nodes which match id to html
    set_html: Str &#8594; Str  &#8594; !
            | id    html = `$(id).html(html)`

    get_html:
    --  Gets the html context of node id

        Str &#8594; ! Str
      | id  = `$(id).html()`</code></pre>
<p>Side effects types via !, implicit monadic composition</p>
<pre><code>    copy_html:

        Str &#8594; Str &#8594; !
      | id1    id2  = do x &lt;- get_html id1
                         set_html id2 x

    copy_html&#39; id1 id2 = get_html id1 &gt;&gt;= set_html id2

    -- _ binds to the nth parameter of the
    -- nearest function scope

    copy_html = join &lt;&lt;&lt; map (\ x = set_html x) &lt;&lt;&lt; get_html

module atom

    type Atom a = { get: ! a, set: a &#8594; ! }

    new : a &#8594; ! (Atom a)
        | x = `function(){var y=x;return {get:function(){return y},set:function(z){y=z}}}`

    get: Atom a &#8594; ! a
    | x = `x.get()`

    swap: Atom a &#8594; (a &#8594; Option a) &#8594; ! a
       | a f = do x &#8592; `a.get()`
                  f x $ \ none: = return x
                        | some: x = do `a.set(x)`
                                       return x 


    atom_monad: Monad (! (Atom a)) =

         { return = new
           bind x f = x &gt;&gt;= (\ x = get x &gt;&gt;= f) }</code></pre>
</div>
   <script type='text/javascript'>
   jasmine.getEnv().addReporter(new jasmine.TrivialReporter());
   jasmine.getEnv().execute();
   </script>
   <script type='text/javascript'>$('code').addClass('prettyprint lang-hs');
   prettyPrint()
   </script>
   </body>
   </html>


