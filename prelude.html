<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN' 'http://www.w3.org/TR/html4/loose.dtd'>
<html><head><title>
prelude
</title>
<link rel='stylesheet' type='text/css' href='lib/js/jasmine-1.0.1/jasmine.css'>
<script type='text/javascript' src='lib/js/jasmine-1.0.1/jasmine.js'></script><script type='text/javascript' src='lib/js/jasmine-1.0.1/jasmine-html.js'></script><script type='text/javascript' src='lib/js/zepto.js'></script><script type='text/javascript' src='prelude.js'></script><script type='text/javascript' src='prelude.spec.js'></script>
<link href='http://kevinburke.bitbucket.org/markdowncss/markdown.css' rel='stylesheet'></link><link href='lib/js/prettify.css' type='text/css' rel='stylesheet' />
<script type='text/javascript' src='lib/js/prettify.js'></script><script type='text/javascript' src='lib/js/lang-hs.js'></script><script type='text/javascript' src='lib/js/jquery.js'></script><style>ul{padding-left:40px;}</style></head><body><div style='margin: 0 0 50px 0'>
<h1 id="sonnet">Sonnet</h1>
<p>A programming language, designed to be read</p>
<hr />
<p>Sonnet is:</p>
<ul>
<li>functional, pure, statically type inferred, eagerly evaluated</li>
<li>flexible syntax that's simple and easy on the eyes</li>
<li>targets V8 Javascript (Chrome &amp; Node.js), Closure Advanced</li>
<li>first class syntax for Javascript, JSON &amp; HTML</li>
<li>first class syntax for assertions &amp; invariant style testing ala QuickCheck, compiler by default generate Jasmine suite</li>
<li>standard lib for events, lazy sequences &amp; comprehensions</li>
<li>directly inspired by Haskell, F#, OCAML, Coffeescript, Clojure, Scala</li>
</ul>
<h2 id="values-and-types">Values and Types</h2>
<p>Anonymous JSON:</p>
<pre><code>type Unit = {}   

type Complex = { real: Num, img: Num }</code></pre>
<p>Named JSON - this is basically a special function that takes an anonymous JSON as an argument and returns the same value of a new type, with the option of ignoring the <code>{}</code> in such values which take a <code>Unit</code> type as an argument.</p>
<pre><code>type Point = point { x: Num, y: Num }

type Unit&#39; = unit  </code></pre>
<p>Union JSON - which is simply a set of any of the above or of the native JSON types, separated by either new lines w/indentation, or <code>|</code></p>
<pre><code>type Option a = { some: a } | none 

type Bool = true | false</code></pre>
<p>Polymorphic JSON, which are any of the above with an introduction of a some type variables into scope:</p>
<pre><code>type List a = 
    { head: a, tail: List a }
    nil

type Map key value =
    from_list { items: List (key, value) }
    empty


{ x = real, y = img } * { u = real, v = img } = 
    { real = x * u - y * v, img = x * v - y * u }  

-- Alternatively:
-- x * y = { real = x.real * y.real - x.img * y.img
--           img =  x.real * y.img - x.img * y.real }</code></pre>
<p>Inherited JSON, which is polymorphic to the type it inherits from, and is declared using the <code>with</code> keyword:</p>
<pre><code>type Semigroup a = { zero: a }

type Monoid a = { Semigroup with + : a &#8594; a &#8594; a }</code></pre>
<h2 id="definitions">Definitions</h2>
<p>Modules define a scope for a collection of definitions. Nesting modules is allowed, but only when the nesting is explicit via indentation.</p>
<pre><code>module List</code></pre>
<p>Definitions are specified via <code>=</code>, types via <code>:</code>, and assertions via <code>?</code>. A definition must be named once, and defines an indented scope for further specifiers. These may redeclare their scope if preferred.</p>
<pre><code>--- Returns the first element of a list
head: [a]        &#8594; a
    | [x &amp; _]    = x
    | nil         = undefined   -- head is not defined for an empty list.   </code></pre>
<p>JSON may also be destructed positionally if all keys are accounted for:</p>
<pre><code>tail: 

    [a] &#8594; a
  | [_ &amp; x] = x
  | []       = undefined 

  tail [3] == 3
  tail [5 1 2] == [1 2]

--- Applies f recursively from the last element of the list.  Consumes 
--  much stack (Haskell style)

foldr: (a &#8594; b &#8594; a) &#8594; b &#8594; [a] &#8594; b
foldr f x [] = x
foldr f x {y, ys} = f y (foldr f x ys) 

length:
--- Returns the cardinality of a list (mixed style)

    [_]      &#8594; Int
  | []        = 0
  | [ _, xs ] = 1 + length xs

length [] == 0
length [1] == 1
length [1 3 2 4] == 4</code></pre>
<p>Though comments are defined via --, the alternative --- defines metadata in the form of a string which applies to the previous symbol. The use of undefined above logs its metadata when it is evaluated, and provides documentation for the function itself.</p>
<p>Anonymous functions may be declared with <code>&#955;</code> in two different forms, via pattern match (haskell-style) or via variable &quot;templating&quot; (clojure style):</p>
<pre><code>tail = &#955; [_ &amp; y] = y
       | []      = undefined</code></pre>
<p>or via variable &quot;templating&quot; (clojure style):</p>
<pre><code>fmap (&#955;_ + 1) [1 2 3] ? [2 3 4] </code></pre>
<h2 id="assertions">Assertions</h2>
<h2 id="patterns">Patterns</h2>
<pre><code>type ReverseList = reverse_list { reverse_list: [] }

reverse [x &amp; xs] = reverse xs + x | [] = []

last: [a]                 &#8594; a
    | (reverse [x &amp; _]) = x
    | _                    = undefined

type Parity = even | odd

length_parity [_ &amp; (length_parity &#8594; even)] = odd | _ = even    

length_parity&#39; [_ &amp; xs] = length_parity xs |&gt; (&#955; even = odd | _ = even)</code></pre>
<h2 id="implicits">Implicits</h2>
<p>Any number of consecutive starting parameters of a function, and/or the last parameter, may be marked as implicit, which simply means that if the type checker fails, the compiler will attempt to &quot;fill in&quot; parameters marked implicit with a unique instance in scope. For example, Haskell's Show type class can be easily implemented as a function with an implicit return type:</p>
<pre><code>complex_to_string: 

    Complex          &#8594; ^Str
  | x when x.img == 0 = string x.real
  | x when x.img &gt; 0  = string x.real + &quot; + &quot; + x.img + &quot;i&quot;
  | x                 = string x.real + &quot; - &quot; + x.img + &quot;i&quot;</code></pre>
<p>The <code>{}</code> makes this function implicit. As there is now a unique implicit instance of a function which converts <code>Complex</code> to <code>Str</code>, we may now use <code>Complex</code> types in places where we would otherwise use a string.</p>
<pre><code>length { real = 2.0, img = 3.0 } == 10</code></pre>
<p>Implicit parameters other than the return type may be optionally left out of the function invocation - as long as there is a unique instance in scope which satisfies the type signature, it will be inserted automatically.</p>
<pre><code>type Functor f = { map: (a &#8594; b) &#8594; f a &#8594; f b }

fmap: ^(Functor f) &#8594; (a - &gt; b) &#8594; f a &#8594; f b
    | functor         g            m    = functor.map g m

fmap func (f . g) x == fmap func f &lt;| fmap func g x
fmap func id x == x

{ map _ [] = [] 
  map f [x &amp; xs] = f x &amp; map f xs }</code></pre>
<p>There is a single instance of Functor List in scope (even though it has no name), so fmap can be invoked on lists with no Functor param</p>
<pre><code>fmap (&#955;_ + 1) [1 2 3] ? [2 3 4] </code></pre>
<p>Here's a few sample Haskell type classes encoded as regular ADTs, then instantiated such that they may be useful as implicit parameters:</p>
<pre><code>type Applicative f =

    { Functor f where 
          return: a &#8594; f a
          ** :    f (a &#8594; b) &#8594; f a &#8594; f b }

applicative = { map f x = return f ** x ... }  

forall f u v w x y 	

    return id ** v == v                        -- Identity
    return (.) ** u ** v ** w == u ** (v ** w) -- Composition
    return f ** return x == return (f x)       -- Homomorphism
    u ** return y == return (&#955; _ y) ** u       -- Interchange      

type Monad m =

    { Applicative m with
          &gt;&gt;= : m a &#8594; (a &#8594; m b) &#8594; m b
          join: m (m a) &#8594; m a }

monad = 
    { applicative with
          x ** y  = x &gt;&gt;= &#955; map _ y
          x &gt;&gt;= f = join (map f x)
          join x  = x &gt;&gt;= id
          ... }

return x &gt;&gt;= f == f x                   -- Left identity
x &gt;&gt;= return == x                       -- Right identity              
(f &gt;&gt;= g) &gt;&gt;= h == f &gt;&gt;= (&#955; g _ &gt;&gt;= h)  -- Commutatative </code></pre>
<p>Since the type of this instance is inferable and we aren't naming it, we can declare instance simply like this:</p>
<pre><code>{ zero         = []
  (x :: y) + z = x :: (y + z)
  []       + x = x }

? zero + [1] + zero = [1]
? [2 3] + zero + [1] = [2 3 1]</code></pre>
<p>Though in some cases, we may want to give it a name and or type annotation:</p>
<pre><code>list_monad =

    { monad with 
          return x = [x]
          xs &gt;&gt;= f = reduce (&#955;_ + _) (map f y)
          [] &gt;&gt;= f = zero }

map list_monad fib [] == zero
map list_monad fib [0 1] == [1 1]
map list_monad fib [6] == [13]
map list_monad fib [2 3 4 5] == [1 2 3 5]</code></pre>
<h2 id="javascript-html">Javascript &amp; HTML</h2>
<p>Sonnet's standard IO library covers many common browser &amp; node.js libraries, but the language itself has no support for IO per se. Rather, side effects are only allowed to occur in quoted javascript, which has slightly different rules than standard javascript, but compiles into basically what you expect.</p>
<pre><code>log: Str &#8594; !
log x = `console.log(x)`</code></pre>
<p>The return type of any quoted javascript is a special IO type <code>a!</code>, where a is inferred to be <code>()</code> when not provided.</p>
<pre><code>io_monad: Monad !
    = { return x = `function() { return x }`
        x &gt;&gt;= f  =  `f(x())` }

module JQuery
--  Library of useful JQuery wrappers

    set_html:
    --  Sets nodes which match id to html

        Str &#8594; Str  &#8594; !
      | id    html = `$(id).html(html)`

    get_html:
    --  Gets the html context of node id

        Str &#8594; Str!
      | id  = `$(id).html()`</code></pre>
<p>Side effects types via !, implicit monadic composition</p>
<pre><code>    copy_html:

        Str &#8594; Str &#8594; !
      | id1    id2  = x &#8592; get_html id1
                      set_html id2 x

    copy_html&#39; id1 id2 = get_html id1 &gt;&gt;= set_html id2

    -- _ binds to the nth parameter of the
    -- nearest function scope

    copy_html&#39;&#39; = join . map (set_html _) . get_html

module Atom

    type Atom a = { get: a!, set: a &#8594; ! }

    new: a &#8594; Atom! a
    new x = `function(){var y=x;return {get:function(){return y},set:function(z){y=z}}}`

    get: Atom a &#8594; a!
    get x = `x.get()`

    swap: Atom a &#8594; (a &#8594; Option a) &#8594; a!
    swap a f = x &#8592; `a.get()`
               match f x with 
                     none &#8594; return x
                     some x &#8594; `a.set(x)`
                               return x 

    atom_monad: Monad Atom! =         
        { return = new
          x &gt;&gt;= f = x &gt;&gt;= &#955; get _ &gt;&gt;= f }</code></pre>
<script type="text/javascript">$("code").addClass("prettyprint lang-hs");prettyPrint()</script>


</div><script type='text/javascript'>jasmine.getEnv().addReporter(new jasmine.TrivialReporter());jasmine.getEnv().execute();</script><script type='text/javascript'>$('code').addClass('prettyprint lang-hs');prettyPrint()</script></body></html>
