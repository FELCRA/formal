<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN' 'http://www.w3.org/TR/html4/loose.dtd'>
<html>
 <head>
 <title>
prelude
</title>
 
<link rel='stylesheet' type='text/css' href='lib/js/jasmine-1.0.1/jasmine.css'>
<script type='text/javascript' src='lib/js/jasmine-1.0.1/jasmine.js'></script>
 <script type='text/javascript' src='lib/js/jasmine-1.0.1/jasmine-html.js'></script>
 <script type='text/javascript' src='lib/js/zepto.js'></script>
 <script type='text/javascript' src='src/js/table_of_contents.js'></script>
 <script type='text/javascript' src='prelude.js'></script>
 <script type='text/javascript' src='prelude.spec.js'></script>
 
<link href='http://kevinburke.bitbucket.org/markdowncss/markdown.css' rel='stylesheet'></link> <link href='lib/js/prettify.css' type='text/css' rel='stylesheet' />
<script type='text/javascript' src='lib/js/prettify.js'></script>
 <script type='text/javascript' src='lib/js/lang-hs.js'></script>
 <script type='text/javascript' src='lib/js/jquery.js'></script>
 <style>
     ul{
         padding-left:40px;
     };
     .jasmine_reporter{
         position: absolute;
         bottom: 0px;
     }
     a, a:visited, a:active, a:link {
         text-decoration: none;
         color: #cccccc;
     }
     .jasmine_reporter a, .jasmine_reporter a:visited, .jasmine_reporter a:active, .jasmine_reporter a:link {
         text-decoration: none;
         color: #000000;
     }


 </style>
 </head>
 <body>
 <div style='position:fixed;top:0px;bottom:0px;width:100%;background:none;padding:105px 0px 0px 20px;line-height:1.5'>
 <div style='position:absolute;left:0px;width:15%'>
 <div id="contents" style='float:right'>
 </div></div></div>
 <div style='position:absolute;top:0px;left:0px;margin-left:15%; width:85%'>
 <div id='main' style='margin: 0 0 50px 10%'>
<h1 id="formal-prelude">Formal Prelude</h1>
<hr />
<p>Formal is a functional programming language which targets Javascript. Designed for readability and compiler verification, Formal is powerful, flexible and easy to learn.</p>
<pre><code>module prelude</code></pre>
<h2 id="bootstrap">Bootstrap</h2>
<p>Some simple reflection by lifting from Javascript. The definitions of <code>object?</code> and <code>array?</code> must use Javascript's <code>===</code> operator directly here, as the &quot;==&quot; operator defined in <a href="#numbers">Numbers</a> is defined in terms of them.</p>
<pre><code>    object? x = run `typeof x === &quot;object&quot;`
    array? = is_array

    not x = run `!x`

    object? {}
    array? []

    not false
    not (array? {})
    not (object? 0)</code></pre>
<p>Side effects can only happen in Javascript, so we use a monadic container to compose these bits.</p>
<pre><code>    run x = x null

    (&gt;&gt;=) x y = lazy run (y (run x))
    ret x     = lazy x
    (&gt;&gt;) x y  = `x(); return y();`

    log x = `console.log(x)`

    run (do x &lt;- `1 + 4`
            y &lt;- `2 + 3`
            log (&quot;x is &quot; + x + &quot; and y is &quot; + y)
            ans &lt;- `x + y`
            ret (10 == ans))

    run (ret 5) == 5
    run (log &quot;test&quot; &gt;&gt; `5 + 5`) == 10

    time js =

        do start &lt;- `new Date().getTime()`
           js
           stop &lt;- `new Date().getTime()`
           ret (stop - start)</code></pre>
<h2 id="numbers">Numbers</h2>
<p>Some basic aliases to native javascript infix functions.</p>
<pre><code>    (&amp;&amp;) x y = run `x &amp;&amp; y`
    (||) x y = run `x || y`
    (*)  x y = run `x * y`
    (/)  x y = run `x / y`
    (+)  x y = run `x + y`
    (-)  x y = run `x - y`
    (&lt;=) x y = run `x &lt;= y`
    (&gt;=) x y = run `x &gt;= y`
    (&lt;)  x y = run `x &lt; y`
    (&gt;)  x y = run `x &gt; y`</code></pre>
<p>Equality is overloaded to match records and arrays</p>
<pre><code>    (==) x y when object? x &amp;&amp; object? y =
           let result = true
           run `for (key in x) {
                    result = result &amp;&amp; _eq_eq(x[key])(y[key]);
                };
                return result;`
       | x y when array? x &amp;&amp; array? y =
           let result = true
           run `for (z in x) {
                    result = result &amp;&amp; _eq_eq(x[z])(y[z]);
                };
                return (result &amp;&amp; x.length == y.length);`
       | x y = run `x === y`

    (!=) x y = not (x == y)</code></pre>
<p>And a few simple tests to verify the correctness of these implementations. This is not meant to be exhaustive, only a smoke test against regressions.</p>
<pre><code>    (3 * 4) + 5 * 4 == 64 / 2
    4 - 1 != 5 - 10
    (10 &gt;= 5 + 5) != (4 + 5 &lt;= 10 - 2)
    ({test: 1} == {test: 1}) == true
    ({test: 1} != {test: 1}) == false</code></pre>
<p>Fibonacci function</p>
<pre><code>    fib 0 = 0 | 1 = 1 | n = fib (n - 1) + fib (n - 2)</code></pre>
<p>Due to the nested recursion, this is an excellent function for testing the runtime speed versus raw javascript. <code>fast_fib</code> is a trivial javascript implementation of the same function, recursed itself to remove any potential overhead from formal's dispatch mechanism.</p>
<pre><code>    module speedtest

        fast_fib = run `var f = function(n) {</code></pre>
<p>// n === 0 ? 0 : n === 1 ? 1 : f(n - 1) + f(n - 2)</p>
<pre><code>                            if (n === 0) {
                                return 0;
                            } else if (n === 1) {
                                return 1;
                            } else {
                                return f(n - 1) + f(n - 2)
                            };
                        };
                        return f;`

        fast_fib 7 == fib 7</code></pre>
<p>With this, we can set up a simple canary to elt us know if the prelude is suddenly dramatically slower than it reviously was; in this case, we fail a test if the formal version isn't at least 90% as fast as the native javascript version.</p>
<pre><code>        floor = run `Math.floor`

        run &lt;: do fast_time &lt;- time (lazy fast_fib 35)
                  slow_time &lt;- time (lazy fib 35)
                  let ratio = floor &lt;| fast_time / slow_time * 100
                  log (&quot;Runtime speed ~&quot; + ratio + &quot;%&quot;)
                  ret (ratio &gt;= 50)</code></pre>
<h2 id="function-combinators">Function Combinators</h2>
<p>Simple left &amp; right pipes, ala F#.</p>
<pre><code>    (&lt;|) x y = x y
    (|&gt;) x y = y x

    3 |&gt; (\y = y + 1) |&gt; (\y = y + 1)    == 5
    (\y x z = x + y + z + 1) 1 &lt;| 3 &lt;| 4 == 9</code></pre>
<p>Alternatively, there is a right associative version of <code>&lt;|</code>, ala haskell. All operators which end with a <code>:</code> are right associative.</p>
<pre><code>    (&lt;:) x y = x y

    (\x = x - 3) &lt;: (\x = x - 3) &lt;: 5 + 5 == 4</code></pre>
<p>Function composition</p>
<pre><code>    (.:) x y = \z = x (y z)
    id x = x
    flip f a b = f b a

    ((\x = x + 1) .: (\x = x * 2) .: (\x = x - 3)) 4 == 3
    id [1, 2, 3] == [1, 2, 3]
    flip (\x y = x - y) 3 5 == 2</code></pre>
<h2 id="tests">Tests</h2>
<p>By invoking javascript, we can listen for exceptions.</p>
<pre><code>    err x = run `try {
                     x();
                     return false;
                 } catch (e) {
                     return e;
                 }`</code></pre>
<h2 id="option">Option</h2>
<pre><code>    type Option a = some: a | none:

    option b nil: = b
         | _ (some: x) = x

    option 3 (some: 2) == 2</code></pre>
<h2 id="lists">Lists</h2>
<p>A simple implementation of a library for manipulating linked lists.</p>
<pre><code>    module list

        type List a = cons: { head: a, tail: List a } 
                      | nil:</code></pre>
<p>This complex type can be hidden behind a constructor function which works more like a traditional cons.</p>
<pre><code>        (::) x y = cons: { head = x, tail = y }

        1 :: 2 :: nil: == 1 :: 2 :: nil:
        nil: :: nil:   == cons: { head = nil:, tail = nil: }
        3 :: 4 :: nil: ==

            cons: { head: 3
                    tail: cons: { head: 4
                                  tail: nil: }}</code></pre>
<p>Simple implementations of list accessors, which illustrate incomplete definition.</p>
<pre><code>        empty? nil: = true | _ = false

        head (cons: { head: x }) = x | nil: = error &quot;Head called on empty list&quot;
        tail (cons: { tail: x }) = x | nil: = error &quot;Tail called on empty list&quot;
        last (cons: { head: x, tail: nil: }) = x
           | (cons: { tail: x }) = last x
           | nil: = error &quot;Last called on empty list&quot;

        take 0 _ = nil: | n x = head x :: take (n - 1) (tail x)
        drop 0 x = x | n x = drop (n - 1) (tail x)


        not (empty? (1 :: nil:))
        empty? (nil:)

        head (1 :: 2 :: nil:)  == 1
        tail (1 :: 2 :: nil:)  == 2 :: nil:
        last (1 :: 2 :: nil:)  == 2
        err (lazy head (nil:)) == &quot;Head called on empty list&quot;
        err (lazy tail (nil:)) == &quot;Tail called on empty list&quot;
        err (lazy last (nil:)) == &quot;Last called on empty list&quot;

        take 2 (1 :: 2 :: 3 :: nil:) == 1 :: 2 :: nil:
        drop 2 (1 :: 2 :: 3 :: nil:) == 3 :: nil:</code></pre>
<p>Cardinality</p>
<pre><code>        length nil: = 0
             | (cons: { tail: x }) = 1 + length x

        length (1 :: 2 :: 3 :: 4 :: nil:) == 4</code></pre>
<p>Generators</p>
<pre><code>        init 0 _ = nil:
           | n x = x :: init (n - 1) x

        length (init 30 0) == 30
        tail (init 3 0)    == init 2 0</code></pre>
<p>List concatenation</p>
<pre><code>        (++) nil: y = y
           | (cons: { head: y, tail: ys }) xs = 
               y :: (ys ++ xs)

        nil: ++ (1 :: 2 :: nil:) == 1 :: 2 :: nil:
        (1 :: 2 :: nil:) ++ (3 :: 4 :: nil:) == 
            1 :: 2 :: 3 :: 4 :: nil:</code></pre>
<p>Filter</p>
<pre><code>        filter f nil: = nil:
             | f x when f (head x) = head x :: filter f (tail x)
             | f x = filter f &lt;| tail x

        filter (\x = x &gt; 2) (1 :: 2 :: 3 :: 4 :: nil:) == 3 :: 4 :: nil:</code></pre>
<p>Map</p>
<pre><code>        map f nil: = nil:
          | f x = f (head x) :: map f (tail x)

        map (\x = x + 1) (1 :: 2 :: 3 :: nil:) == 
            2 :: 3 :: 4 :: nil:</code></pre>
<p>Reverse</p>
<pre><code>        reverse = 
            let r rest nil: = rest
                | rest (cons: { head: x, tail: xs }) = 
                    r (x :: rest) xs

            r (nil:)

        reverse (1 :: 2 :: 3 :: 4 :: nil:) ==
            4 :: 3 :: 2 :: 1 :: nil:</code></pre>
<p>Folds</p>
<pre><code>        foldl f x xs =
            let g y nil: = y
                | y (cons: { head: z, tail: zs }) = g (f y z) zs
            g x xs

        foldl1 _ nil: = error &quot;Foldl1 called on empty list&quot;
             | f x = foldl f (head x) (tail x)

        foldr f x =
            let g nil: = x
                | (cons: { head: y, tail: ys }) = f y (g ys)
            g

        foldr1 _ nil: = error &quot;Foldr1 called on empty list&quot;
             | f x = foldr f (head x) (tail x)

        all? f = foldl1 (\x y = f x &amp;&amp; f y)
        any? f = foldl1 (\x y = f x || f y)

        sum     = foldl1 (\x y = x + y)
        product = foldl1 (\x y = x * y)

        concat = foldl1 (\x y = x ++ y)
        concat_map f xs = concat (map f xs)

        maximum = foldl1 (\x y = if x &gt; y then x else y)
        minimum = foldl1 (\x y = if x &gt; y then y else x)

        foldl (\x y = x + y) 0 (1 :: 2 :: 3 :: 4 :: nil:) == 10
        foldr (\x y = x + y) 0 (1 :: 2 :: 3 :: 4 :: nil:) == 10
        all? id (true :: true :: nil:)
        not (all? id (true :: false :: nil:))
        any? id (true :: false :: nil:)
        not (any? id (false :: false :: nil:))
        sum (1 :: 2 :: 3 :: nil:) == 6
        product (1 :: 2 :: 4 :: nil:) == 8

        concat ((1 :: 2 :: nil:) :: (3 :: 4 :: nil:) :: nil:) ==
            1 :: 2 :: 3 :: 4 :: nil:

        concat_map (\x = (x :: x + 1 :: nil:)) (1 :: 2 :: 3 :: 4 :: nil:) ==
             1 :: 2 :: 2 :: 3 :: 3 :: 4 :: 4 :: 5 :: nil:

        minimum (1 :: 2 :: 3 :: nil:) == 1
        maximum (1 :: 2 :: 3 :: nil:) == 3</code></pre>
<h2 id="sequences">Sequences</h2>
<p>Sequences are an abstract data type which resembles a list, except that elemnts of a sequence are constructed lazily as they are requested.</p>
<pre><code>    module sequence

        open list

        type Seq a = Js ( { val: a, next: Seq a } | end: )</code></pre>
<p>Converting a <code>List</code> to a <code>Seq</code> is simple and O(1) as the list need not be walked</p>
<pre><code>        from_list nil: = lazy end:
                | x    = lazy { val: head x, next: from_list (tail x) }</code></pre>
<p>... but converting back is not.</p>
<pre><code>        to_list =
            let f { val: x, next: xs } = x :: to_list xs
                | end: = nil:
            f .: run

        to_list (from_list (1 :: 2 :: nil:)) == 1 :: 2 :: nil:</code></pre>
<p>Sequences may be infinite, as long as you never try to read every element. However, the current implementation is stack-consuming and thus limited by the underlying javascript runtime ...</p>
<pre><code>        iterate f x = lazy { val: x, next: iterate f (f x) } 

        take 0 _ = lazy end:
           | n x = do y &lt;- x
                      ret (y |&gt; \ end: = end:
                                | { val: y, next: ys } = 
                                    { val: y
                                      next: take (n - 1) ys })

        1 :: 2 :: 3 :: nil: == 
            (1 :: 2 :: 3 :: 4 :: nil:) |&gt; from_list 
                                       |&gt; take 3
                                       |&gt; to_list

        500 == iterate (\x = x + 1) 0
               |&gt; take 500
               |&gt; to_list
               |&gt; length</code></pre>
<h2 id="maps">Maps</h2>
<pre><code>    module map

        type Map a b = map: Array { key: a, val: b }

        (%) x y = { key = x, val = y }

        &quot;test&quot; % true == { key = &quot;test&quot;, val = true }


open prelude</code></pre>
</div>
 </div>
 </body>
 </html>


