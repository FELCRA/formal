-- Formal is a functional programming language for the people, targetting
-- Javascript.  Designed around the principles of readability, verifiability and
-- simplicity, Formal takes the pain out of ML, while simultaeniously bringing a
-- little discipline to Javascript.

-- Philosophy
--
--   * Strong static typing and automated testing are compilimentary, equally
--     powerful tools for verifying program correctness, as well as designing
--     an application architecture and communicating this architecture effectively
--     to other programmers.

-- Features:

--   * Heavily inspired by Haskell, F#, Coffeescript, ML.  Type inferred, curried,
--     strictly evaluated.

--   * Hybrid type system - Formal features a complete polymorphic type
--     inferrence engine w/structural types ala ML, with a twist.  The type of a
--     definition with an explicit type signature is verifed just like any other
--     ML, but for implicitly typed definitions, a failure to infer a principal
--     type only emits a warning by default, and the type of the definition is
--     assumed to be dynamic (ie unifies with all types).  If you don't like
--     spending time keeping your application's types consistent while working on an
--     experimental or rapidly changing codebase, Formal lets you code first, type
--     later.
    
--   * First class testing - In Formal, types and tests are equal first class
--     citizens of the language.  Formal allows you to write inline, definition
--     scope assertions about the expected behavior of your functions, which
--     compile to a seperate [Jasmine](http://pivotal.github.com/jasmine) test
--     suite.  Definitions not referenced in an assertion emit compiler warnings,
--     and the test suite is run by default (just like the type checker).  No more
--     excuses for not testing your code!

--   * Inline Javascript - For bootstrapping, quickly importing a Javascript
--     library, accessing un-formalized APIs or simply writing fast mutation
--     algorithms "natively", Formal allows quick and easy anti-quoting into
--     Javascript with backticks (`). Together with dynamic types, this allow
--     no-fuss interfacing with Javascript when you need it, but still allows you
--     to tell the type checker explicitly what types to expect when you get around
--     to it.

--   * Simple data types - The basic data types in Formal are the exact same basic
--     data types of Javascript:  Num, String, Array, Object.  Despite this
--     simplicity, Formal supports many of the features of the fuly algebraic data
--     types of languages like ML and Haskell, including partial object types,
--     polymorphic type unions, synonyms, existential types and more.
    
--   * Advanced pattern matching - Traditional pattern matching goodness with a few
--     extras: match on record partials & define your own matches with view
--     patterns.
    
--   * Pure by default - Like Haskell, any function which has a side effect returns
--     the polymorphic type `JS a` by default, including any inline Javascript, and
--     these types can be composed without evaluation via `do` sugar or any other
--     combinator.  Unlike haskell, `JS a` types can be trivially unwrapped
--     anywhere via `do!` (type `JS a -> a`), even inside a pure function.  Formal
--     gives you the power of choice:  side effects are restricted by
--     default, but if you need to log a messages deep in a pure library or want a
--     function to mutate a variable for speed, just `do!` it.
    
--   * Targets Closure advanced mode - Formal does not aim to emit readable
--     Javascript, instead opting to produce the most efficient output possible.
--     To this end, it currently relies heavily on Google Closure's advanced
--     optimizations mode for aggressive function inlining & dead code elimination.

-- This document is a both the compiler's README, and the Formal language's
-- standard library as literate code, which serves as a simple language feature
-- spec/tutorial

-- Installation
-- ------------

-- Mac OSX (tested on Snow Leopard & Lion)

-- 1. Install the
-- [Haskell Platform](http://hackage.haskell.org/platform/index.html)

-- 2. Install [Node.js](http://nodejs.org/), preferably via
-- [Homebrew](http://mxcl.github.com/homebrew/).  This is only strictly necessary
-- if you want the compiler to run your test suite - you can develop browser
-- applications without Node if you want.

-- 3. Clone the formal repo via

--    <pre><code>--$ git clone git://github.com/texodus/formal.git</code></pre>
    
-- 4. Change to the formal directory and run cabal install

--    <pre><code>--$ cd formal
--       --$ cabal install</pre></code>
    
-- 5. Open a beer, you've had a long day!  The `formal` executable should now be on
--    your path.

-- To compile some formal files:
   
--        <pre><code>--$ formal -o app test.formal test2.formal</pre></code>

-- will create an app.js, app.spec.js and app.html file with the compiled code,
-- test suite and annotated documentation respectively.  To compile literate
-- formal (eg, Formal code embedded in Markdown, ala this file):
   
--        <pre><code>--$ formal test.lformal</pre></code>
   
-- To see the inferred types:
   
--        <pre><code>--$ formal -t test.formal</pre></code>
   
-- To turn off optimizing (eg, Closure) or testing:
   
--        <pre><code>--$ formal -no-test -no-opt test.formal</pre></code>

-- Formal is a literate language embedded in
-- [Markdown](http://daringfireball.net/projects/markdown/syntax), so any
-- line not indented at least 4 spaces is considered a comment.  The
-- primary unit of code organization is the `module`, a named collection
-- of functions and values.

module prelude

    -- Bootstrap
    -- ---------
    -- Some simple reflection by lifting from Javascript.  The definitions of
    -- `object?` and `array?` must use Javascript's `===` operator directly
    -- here, as the "==" operator defined in [Numbers](#numbers) is defined
    -- in terms of them.

    object? x = do! `typeof x === "object"`
    array? = do! `is_array`
    type? x = do! `typeof x`
    
    not: Bool -> Bool | x = do! `!x`

    object? {}
    array? []

    not false
    not (array? {})
    not (object? 0)

    -- Side effects can only happen in Javascript, so we use a monadic container to
    -- compose these bits.

    (>>=): JS a -> (a -> JS b) -> JS b | x y = `run (y (run x))`
    (>>): JS a -> JS b -> JS b         | x y = `run x; return (run y)`
    return: a -> JS a                  | x   = `x`
    
    do! x <- `1 + 4`
        y <- `2 + 3`
        ans <- `x + y`
        return (10 == ans)
              
    5  == do! return 5
    10 == do! `5 + 5`

    -- Purely side-effectful functions are not posible to annotate with an explicit
    -- type currently.  This is due to a bug in the current compiler implementation,
    -- that the Unit type is not expressable as a value in the type checker.  Once
    -- resolved, `log: a -> JS {}`

    log x = `console.log(x)`

    -- Testing to verify that escaping Javascript & utilizing escaped
    -- Javascript with `do` sugar and composition in general works as
    -- expected.

    let x = 0
        y = do z <- `x = 1`
               return z
    x == 0


    -- Numbers
    -- -------
    -- Some basic aliases to native javascript infix functions.  These are type
    -- annotated to constrain inferrence - otherwise, these functions would all be
    -- inferred as `a -> b -> c`.

    (&&): Bool -> Bool -> Bool | x y = do! `x && y`
    (||): Bool -> Bool -> Bool | x y = do! `x || y`
    (*):  Num -> Num -> Num    | x y = do! `x * y`
    (/):  Num -> Num -> Num    | x y = do! `x / y`
    (%):  Num -> Num -> Num    | x y = do! `x % y`
    (+):  Num -> Num -> Num    | x y = do! `x + y`
    (-):  Num -> Num -> Num    | x y = do! `x - y`
    (<=): Num -> Num -> Bool   | x y = do! `x <= y`
    (>=): Num -> Num -> Bool   | x y = do! `x >= y`
    (<):  Num -> Num -> Bool   | x y = do! `x < y`
    (>):  Num -> Num -> Bool   | x y = do! `x > y`
    
    -- Equality is overloaded to match records and arrays. By constraining the type of
    -- this operator, we need only dispatch on the type of the first element,
    -- constraining 

    (!=) x y = not (x == y)

    (/=) x y = not (x == y)

    (==): a -> a -> Bool
        | x y when object? x && object? y =
            let result = true
            do! `for (key in x) {
                    result = result && y.hasOwnProperty(key) && _eq_eq(x[key])(y[key]);
                 };

                 var z = Object.keys(x).length 
                             === Object.keys(y).length;

                 result && z`
                 
        | x y when array? x && array? y =
            let result = true
            do! `for (z in x) {
                     result = result && _eq_eq(x[z])(y[z]);
                 };

                 result && x.length == y.length`

        | x y = do! `x === y`

    -- And a few simple tests to verify the correctness of these
    -- implementations.  This is not meant to be exhaustive, only a smoke
    -- test against regressions.

    (3 * 4) + 5 * 4 == 64 / 2
    4 - 1 != 5 - 10
    (10 >= 5 + 5) != (4 + 5 <= 10 - 2)
    ({test: 1} == {test: 1}) == true
    ({test: 1} != {test: 1}) == false

    -- Fibonacci function

    fib 0 = 0 | 1 = 1 | n = fib (n - 1) + fib (n - 2)

    -- Strings
    -- -------

    (+++): String -> String -> String | x y = do! `x + y`
    
    let x = "test"
    "hello `x`" == "hello test"
    
    -- Speed
    -- -----

    -- Due to the nested recursion, `fib` is an excellent function for testing the
    -- runtime speed versus raw javascript.  `fast_fib` is a trivial javascript
    -- implementation of the same function, recursed itself to remove any potential
    -- overhead from formal's dispatch mechanism.

    module speedtest

        get_time = `new Date().getTime()`

        time js =

            do start <- get_time
               js
               stop  <- get_time
               return (stop - start)

        fast_fib =
            do! `var f = function(n) {
                     return 0 === n ? 0 : 1 === n ? 1 : f(n - 1) + f(n - 2)
                 }; f`
                
        fast_fib 7 == fib 7
        
        -- With this, we can set up a simple canary to let us know if the prelude is
        -- suddenly dramatically slower than it previously was; in this case, we fail a test
        -- if the formal version isn't at least 90% as fast as the native javascript
        -- version.

        floor: Num -> Num = do! `Math.floor`

        do! fast_time <- time `fast_fib 30`
            slow_time <- time `fib 30`
            log (floor (fast_time / slow_time * 100))
            return (floor (fast_time / slow_time * 100) >= 90)

    -- Function Combinators
    -- --------------------
    -- Simple left & right pipes, ala F#.  

    (<|) x y = x y
    (|>) x y = y x
    
    3 |> (λy = y + 1) |> λy = y + 1 == 5
    (λy x z = x + y + z + 1) 1 <| 3 <| 4 == 9
    
    -- Alternatively, there is a right associative version of `<|`, ala
    -- haskell.  All operators which end with a `:` are right associative.

    (<:) x y = x y
    
    (λx = x - 3) <: (λx = x - 3) <: 5 + 5 == 4
    
    -- Function composition

    (.:) x y = λz = x (y z)
    id x = x
    flip f a b = f b a
     
    ((λx = x + 1) .: (λx = x * 2) .: λx = x - 3) 4 == 3
    id [1, 2, 3] == [1, 2, 3]
    flip (λx y = x - y) 3 5 == 2
    
    -- Partial records tests - these need to be moved to some sort of test suite
    -- eventually, when I'm not using the prelude as a test suite [TODO].
    
    let f {a: x, b: y, _ } = x + y
    f { a: 5, b: 5, c: 5 } == f { a: 5, b: 5, d: 5 }

    let f {a: 1, b: 1, _ } = 2
        | {b: 2, c: 2, _ } = 2
    f {a:1,b:1,c:3,d:5} + f {a:1,b:2,c:2,e:5} == 4

    let f {a: 1, b: 2, _ } = 1
        g {b: 2, c: 3, _ } = 2
        x = {a: 1, b: 2, c: 3, d: 4 }
    f x + 1 == g x

    -- Tests
    -- -----
    -- By invoking javascript, we can listen for exceptions.

    err x = do! `try {
                     x();
                     return false;
                 } catch (e) {
                     return e;
                 }`

    -- Option
    -- ------

    module option
    
        Option a = some: a | none:
        
        option b none: = b
             | _ (some: x) = x
             
        option 3 (some: 2) == 2

    module html

        HTML = { element:   a
                 inner:     JS String
                 on_click:  JS a -> JS b     -- TODO it is obnoxious that these must be unique
                 set:       c -> JS d        --      type variables - need {} ...
                 add_class: String -> JS e
                 add_style: String -> String -> JS f }

        ($=): String -> a -> JS b
            | x y = `if (typeof $ != "undefined") { $(x).get(0).innerHTML = y; }`

        ($|): String -> String -> String -> JS a
            | x y = \z = `$(x)["css"](y, z)`

        ($.): String -> String -> JS a
            | x y = `$(x)["addClass"](y)`

        get: String -> JS HTML
            | x = do el <- `$(x).get(0)`
                     return { element       = el
                              inner         = `el.innerHTML`
                              on_click y    = `el.onclick = y`
                              set y         = `el.innerHTML = y`
                              add_class y   = `el.setAttribute("class", el.getAttribute("class") + " " + y)`
                              add_style y z = `el.style[y] = z` }

        move: HTML -> HTML -> JS a
            | x y = `$(y.element).append($(x.element).detach())`
                       
        on_load: JS a -> JS b
            | x = `window.addEventListener("load", x, false)`

        stringify: a -> String | x = do! `JSON.stringify(x)`

        (!!): Array a -> Num -> a | x y = do! `x[y]`

        with_page: JS a -> JS a
            | x = do old <- get "body"
                     `old.element.detach()`

        do! "body" $= "I am a test!"
            text <- get "body"
            text <- text.inner
            return (text == "I am a test!")

                         

        -- This is the initializer for prelude's console test suite.  The javascript
        -- in this function is heavily sanitized against Closure, which 
        -- should in the future be handled automagically [TODO]

        console =

            let report spec = 

                    do! results <- `spec.results()`
                        passed  <- `results.passed()`

                        if   passed 
                        then return 0
                        else do items <- `spec.results_.items_`
                                desc  <- `spec.description.split("::")[1]`
                                line  <- `parseInt(spec.description.split("::")[0].split("_")[0]) + 1`
                                
                                log ""
                                log "Test failed: `desc`
                                         at line `line`
                                
                                         Expected `stringify ((items !! 0).expected)`
                                         Actual   `stringify ((items !! 0).actual)`"

                reporter = { reportSpecResults:   report 
                             reportRunnerResults: do `phantom.exit(1)` }

            do env <- `jasmine.getEnv()`
               log <- `window.console.log`

               `env.addReporter(reporter)`
               `env.execute()`



        -- This is the initializer for prelude's HTML test suite.  The javascript
        -- in this function is heavily sanitized against Closure, which 
        -- should in the future be handled automagically [TODO]

        table_of_contents =

            on_load do "code"  $. "prettyprint"
                       "code"  $. "lang-hs"

                       ".test" $| "position" <| "relative"
                       ".test" $| "left"     <| "50px"

                       `prettyPrint()`

                       trivial <- `new jasmine.TrivialReporter()`
                       formal  <- `new jasmine.FormalReporter()`
                       env     <- `jasmine.getEnv()`

                       `env.addReporter trivial`
                       `env.addReporter formal`

                       `env.execute()`

                       reporter <- get ".jasmine_reporter"
                       body     <- get "body div"

                       move reporter body
                       
        

    -- Lists
    -- -----
    -- A simple implementation of a library for manipulating linked lists.

    module list
    
        List a = { head: a, tail: List a } 
               | nil:
                 
        -- This complex type can be hidden behind a constructor function which
        -- works more like a traditional cons.

        (::) x y = { head = x, tail = y }

        -- The compiler itself also supports the list sugar `[: 1, 2, 3 ]` (or
        -- `[: 1, 2, 3 :]`, if you prefer symmetry).  All of these lists are
        -- synonyms.

        let xs = [: [: 1, 2, 3 ]
                    [: 1, 2, 3 :]
                    ( 1 :: 2 :: 3 :: nil: )
                    { head: 1
                      tail: { head: 2
                              tail: { head: 3
                                      tail: nil: }}} ]

        all? (λy = [:1,2,3] == y) xs 
                           

        -- Simple implementations of list accessors, which illustrate
        -- incomplete definition.

        empty? nil: = true | _ = false

        head { head: x, tail: _ } = x
           | nil: = error "Head called on empty list"
           
        tail { head: _, tail: x } = x 
           | nil: = error "Tail called on empty list"
           
        last { head: x, tail: nil: } = x
           | { head: _, tail: x } = last x
           | nil: = error "Last called on empty list"

        take 0 _ = nil: | n x = head x :: take (n - 1) (tail x)
        drop 0 x = x | n x = drop (n - 1) (tail x)

        (..) x y when x < y = x :: (x + 1 .. y)
           | x _ = [:x]
           
        1 .. 5 == [:1,2,3,4,5]

        -- Project Euler problem 1, modified to protect the innocent:

        288045 == 1 .. 1111 |> filter (λx = x % 3 == 0 || x % 5 == 0) |> sum

        take_while f nil: = nil:
                 | f x when f (head x) = head x :: filter f (tail x)
                 | _ _ = nil:

        drop_while f nil: = nil:
                 | f x when f (head x) = drop_while f (tail x)
                 | _ x = x

        not (empty? (1 :: nil:))
        empty? [:]
   
        head [: 1, 2 ] == 1
        tail [: 1, 2 ] == [:2]
        last [: 1, 2 ] == 2

        err (lazy head nil:) == "Head called on empty list"
        err (lazy tail nil:) == "Tail called on empty list"
        err (lazy last nil:) == "Last called on empty list"

        take 2 [: 1, 2, 3 ]  == [: 1, 2 ]
        drop 2 [: 1, 2, 3 ]  == [: 3 ]

        take_while (λx = x < 0) [:] == [:]
        take_while (λx = x > 0) [: 2, 1, 0 ] == [: 2, 1 ]

        drop_while (λx = x < 0) nil: == nil:
        drop_while (λx = x > 0) [: 2, 1, 0 ] == [: 0 ]

        -- Cardinality
        
        length nil: = 0
             | { head: _, tail: x } = 1 + length x
             
        length [: 1, 2, 3, 4 ] == 4

        -- Generators

        init 0 _ = nil:
           | n x = x :: init (n - 1) x
           
        length (init 30 0) == 30
        tail (init 3 0)    == init 2 0

        -- List concatenation

        (++) nil: y = y
           | { head: y, tail: ys } xs = 
               y :: (ys ++ xs)

        nil: ++ (1 :: 2 :: nil:) == 1 :: 2 :: nil:
        [: 1, 2 ] ++ [: 3, 4 ] == [: 1, 2, 3, 4 ]

        -- Filter

        filter: (a -> Bool) -> List a -> List a
              | f nil: = nil:
              | f x when f (head x) = head x :: filter f (tail x)
              | f x = filter f <| tail x
                        
        filter (λx = x > 2) [: 1, 2, 3, 4 ] == [: 3, 4 ]

        -- Map

        map f nil: = nil:
          | f x = f (head x) :: map f (tail x)
          
        map (λx = x + 1) [: 1, 2, 3 ] == [: 2, 3, 4 ]
            
        -- Reverse

        reverse = 
            let r rest [:] = rest
                | rest { head: x, tail: xs } = 
                    r (x :: rest) xs

            r nil:
        
        reverse [: 1, 2, 3, 4 ] == [: 4, 3, 2, 1 ]

        -- Folds

        foldl f x xs =
            let g y nil: = y
                | y { head: z, tail: zs } = g (f y z) zs
            g x xs

        foldl1 _ nil: = error "Foldl1 called on empty list"
             | f x = foldl f (head x) (tail x)
             
        foldr f x =
            let g nil: = x
                | { head: y, tail: ys } = f y (g ys)
            g

        foldr1 _ nil: = error "Foldr1 called on empty list"
             | f x = foldr f (head x) (tail x)
             
        all? f = foldl1 (λx y = x && y) .: map f
        any? f = foldl1 (λx y = x || y) .: map f

        sum     = foldl1 (λx y = x + y)
        product = foldl1 (λx y = x * y)
        
        concat = foldl1 (λx y = x ++ y)
        concat_map f xs = concat (map f xs)
        
        maximum = foldl1 (λx y when x > y = x | _ y = y)
        minimum = foldl1 (λx y = if x > y then y else x)

        foldl (λx y = x + y) 0 [: 1, 2, 3, 4 ] == 10
        foldr (λx y = x + y) 0 [: 1, 2, 3, 4 ] == 10
        all? id [:true,true]
        not (all? id [:true,false])
        any? id [:true,false]
        not (any? id [:false,false])
        sum [:1,2,3] == 6
        product [:1,2,4] == 8

        let x = [:1,2]
            y = [:3,4]
        concat [:x,y] == [:1,2,3,4]

        concat_map (λx = [:x,x+1]) [:1,2] == [:1,2,2,3]
             
        minimum [: 1, 2, 3 ] == 1
        maximum [: 1, 2, 3 ] == 3
        

    -- Sequences
    -- ---------
    -- Sequences are an abstract data type which resembles a list, except that elements
    -- Sequences may be infinite, as long as you never try to read every element.
    -- However, the current implementation is stack-consuming and thus limited by the
    -- underlying javascript runtime [TODO].  

    module seq

        open list
        open speedtest
        open html
    
        Seq a = seq: JS { elem: a, next: Seq a}
              | end:
                   
        iterate f x = seq: yield { elem: x, next: iterate f (f x) }

        from_list nil: = end:
                | { head: x, tail: xs } =
                    seq: yield { elem: x, next: from_list xs }
                    
        to_list end: = nil:
              | { seq: x } = do! { elem: y, next: ys } <- x
                                 return (y :: to_list ys)

        take _ end: = end:
           | 0 _ = end:
           | x { seq: y } = seq: do { elem: z, next: zs } <- y
                                    return { elem: z, next: take (x - 1) zs }

        to_list (from_list [:1,2]) == [:1,2]
        iterate (λx = x + 1) 0 |> take 100 |> to_list |> length == 100

        zip_with:
        
              (a -> b -> c) -> Seq a -> Seq b -> Seq c
            | _ end:     _        = end:
            | _ _        end:     = end:
            | f {seq: a} {seq: b} =

                seq: do { elem: xx, next: xs } <- a
                        { elem: yy, next: ys } <- b

                        return { elem: f xx yy, next: zip_with f xs ys }
                                        
        (:::) x y = seq: yield { elem: x, next: do! y }
        
        tail:
              Seq a   -> Seq a
            | end:     = error "tail called on empty seq"
            | {seq: t} = do! t >>= λx = return x.next
 
        to_lazy end: = end:
              | {seq: y} = seq: lazy do! { elem: x, next: xs } <- y
                                         return { elem: x, next: to_lazy xs }
 
        -- Infinite sequence example
 
        fibs = to_lazy <: 1 ::: return <: 1 ::: yield zip_with (λx y = x + y) fibs <: tail fibs
    
        -- Since the `lazy` keyword memoizes it's argument, this fibonacci implementation
        -- is ridiculously faster than the recursive version.  For example, the runtime
        -- speed of this fib implementation compared to the native recursive one is <span
        -- id="speedtest">__________</span>%.

        do! fast_time <- time yield fast_fib 30
            slow_time <- time yield fibs |> take 30 |> to_list |> last
            let ratio = floor (fast_time / slow_time * 100)
            "#speedtest" $= ratio
            return (ratio >= 2)

        fibs |> take 5 |> to_list == [:1,1,2,3,5]

        fast_fib 15 == fibs |> take 15
                            |> to_list
                            |> last

    -- FormalZ
    -- -------
    -- Demonstration of some classic FP data structures.  This form of polymorphism can
    -- be simulated in Formal the same way they are implemented in Haskell - as a function
    -- dictionary, the only difference being that you must explicitly bind the dictionary
    -- instance to a symbol (as opposed to it being referenced by the type variable's
    -- instantiation).

    module formalz

        open list

        Functor f =

            { map: (a -> b) -> f a -> f b }

        Monad m =

            { (>>=): m a -> (a -> m b) -> m b
              ret: a -> m a }

        map z x f = z.map f x

        bind { ret: f, _ } x = f x

        list_functor =

            { map _ nil: = nil: 
                | f { head: x, tail: xs } =
                      { head: f x
                        tail: list_functor.map f xs }}

        list_monad =

            { (>>=) x g = concat_map g x
              return x = [:x] }

        js_monad   =

            { (>>=) x f = x >>= f
              return x = return x }

        let (>>>=) x g = concat_map g x
            z = 1..3 >>>= λx = [:x,x+1,x+2]
        z == [:1,2,3,2,3,4,3,4,5]

