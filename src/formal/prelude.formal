-- Formal is a functional programming language which targets Javascript.  Designed
-- for readability and compiler verification, Formal is powerful, flexible and easy
-- to learn.  

-- This document is a literate program defining the Formal standard
-- library, namespaced `prelude`.  To compile it, simply clone the repo and run `sh
-- deps.sh && sh build.sh` - this will generate the HTML documentation, compiled
-- Javascript source, [Jasmine](http://pivotal.github.com/jasmine) test suite and
-- Node.js test suite, then run the test suite from Node.  You can also see the
-- results of the Jasmine specifications at the bottom of this document.

-- Formal is a literate language embedded in
-- [Markdown](http://daringfireball.net/projects/markdown/syntax), so any
-- line not indented at least 4 spaces is considered a comment.  The
-- primary unit of code organization is the `module`, a named collection
-- of functions and values.

module prelude
    


    -- Bootstrap
    -- ---------
    -- Some simple reflection by lifting from Javascript.  The definitions of
    -- `object?` and `array?` must use Javascript's `===` operator directly
    -- here, as the "==" operator defined in [Numbers](#numbers) is defined
    -- in terms of them.

    object? x = do! `typeof x === "object"`
    array? = do! `is_array`
    
    not: Bool -> Bool | x = do! `!x`

    object? {}
    array? []

    not false
    not (array? {})
    not (object? 0)

    -- Side effects can only happen in Javascript, so we use a monadic container to
    -- compose these bits.

    (>>=): JS a -> (a -> JS b) -> JS b | x y = `run (y (run x))`
    (>>): JS a -> JS b -> JS b         | x y = `run x; return (run y)`
    ret: a -> JS a                     | x   = `x`
    
    do! x <- `1 + 4`
        y <- `2 + 3`
        ans <- `x + y`
        ret (10 == ans)
              
    5  == do! ret 5
    10 == do! log "test" >> `5 + 5`

    -- Purely side-effectful functions are not posible to annotate with an explicit
    -- type currently.  This is due to a bug in the current compiler implementation,
    -- that the Unit type is not expressable as a value in the type checker.  Once
    -- resolved, `log: a -> JS {}`

    log x = `console.log x`

    -- Testing to verify that escaping Javascript & utilizing escaped
    -- Javascript with `do` sugar and composition in general works as
    -- expected.

    let x = 0
        y = do z <- `x = 1`
               ret z
    x == 0


    -- Numbers
    -- -------
    -- Some basic aliases to native javascript infix functions.  These are type
    -- annotated to constrain inferrence - otherwise, these functions would all be
    -- inferred as `a -> b -> c`.

    (&&): Bool -> Bool -> Bool | x y = do! `x && y`
    (||): Bool -> Bool -> Bool | x y = do! `x || y`
    (*):  Num -> Num -> Num    | x y = do! `x * y`
    (/):  Num -> Num -> Num    | x y = do! `x / y`
    (%):  Num -> Num -> Num    | x y = do! `x % y`
    (+):  Num -> Num -> Num    | x y = do! `x + y`
    (-):  Num -> Num -> Num    | x y = do! `x - y`
    (<=): Num -> Num -> Bool   | x y = do! `x <= y`
    (>=): Num -> Num -> Bool   | x y = do! `x >= y`
    (<):  Num -> Num -> Bool   | x y = do! `x < y`
    (>):  Num -> Num -> Bool   | x y = do! `x > y`
    
    -- Equality is overloaded to match records and arrays. By constraining the type of
    -- this operator, we need only dispatch on the type of the first element,
    -- constraining 

    (!=) x y = not (x == y)

    (/=) x y = not (x == y)

    (==): a -> a -> Bool
        | x y when object? x && object? y =
            let result = true
            do! `for (key in x) {
                    result = result && y.hasOwnProperty(key) && _eq_eq(x[key])(y[key]);
                 };

                 var z = Object.keys(x).length 
                             === Object.keys(y).length;

                 result && z`
                 
        | x y when array? x && array? y =
            let result = true
            do! `for (z in x) {
                     result = result && _eq_eq(x[z])(y[z]);
                 };

                 result && x.length == y.length`

        | x y = do! `x === y`

    -- And a few simple tests to verify the correctness of these
    -- implementations.  This is not meant to be exhaustive, only a smoke
    -- test against regressions.

    (3 * 4) + 5 * 4 == 64 / 2
    4 - 1 != 5 - 10
    (10 >= 5 + 5) != (4 + 5 <= 10 - 2)
    ({test: 1} == {test: 1}) == true
    ({test: 1} != {test: 1}) == false

    -- Fibonacci function

    fib 0 = 0 | 1 = 1 | n = fib (n - 1) + fib (n - 2)

    -- Strings
    -- -------

    (+++): String -> String -> String | x y = do! `x + y`
    
    let x = "test"
    "hello `x`" == "hello test"
    
    -- Speed
    -- -----

    -- Due to the nested recursion, `fib` is an excellent function for testing the
    -- runtime speed versus raw javascript.  `fast_fib` is a trivial javascript
    -- implementation of the same function, recursed itself to remove any potential
    -- overhead from formal's dispatch mechanism.

    module speedtest

        get_time = `new Date().getTime()`

        time js =

            do start <- get_time
               js
               stop  <- get_time
               ret (stop - start)

        fast_fib =
            do! `var f = function(n) {
                     return 0 === n ? 0 : 1 === n ? 1 : f(n - 1) + f(n - 2)
                 }; f`
                
        fast_fib 7 == fib 7
        
        -- With this, we can set up a simple canary to let us know if the prelude is
        -- suddenly dramatically slower than it previously was; in this case, we fail a test
        -- if the formal version isn't at least 80% as fast as the native javascript
        -- version.  This test "primes" the JIT by running the fast calc first,
        -- otherwise in practice the first eval tends to be favored in V8.

        floor: Num -> Num = do! `Math.floor`

        do! fast_time <- time `fast_fib 35`
            slow_time <- time `fib 35`
            `console.log (floor (fast_time / slow_time * 100))`
            ret (floor (fast_time / slow_time * 100) >= 80)


    -- Function Combinators
    -- --------------------
    -- Simple left & right pipes, ala F#.  

    (<|) x y = x y
    (|>) x y = y x
    
    3 |> (λy = y + 1) |> λy = y + 1 == 5
    (λy x z = x + y + z + 1) 1 <| 3 <| 4 == 9
    
    -- Alternatively, there is a right associative version of `<|`, ala
    -- haskell.  All operators which end with a `:` are right associative.

    (<:) x y = x y
    
    (λx = x - 3) <: (λx = x - 3) <: 5 + 5 == 4
    
    -- Function composition

    (.:) x y = λz = x (y z)
    id x = x
    flip f a b = f b a
     
    ((λx = x + 1) .: (λx = x * 2) .: λx = x - 3) 4 == 3
    id [1, 2, 3] == [1, 2, 3]
    flip (λx y = x - y) 3 5 == 2
    
    -- Partial records tests - these need to bemoved to some sort of test suite
    -- eventually, when I'm not using the prelude as a test suite [TODO].
    
    let f {a: x, b: y, _ } = x + y
    f { a: 5, b: 5, c: 5 } == f { a: 5, b: 5, d: 5 }

    let f {a: 1, b: 1, _ } = 2
        | {b: 2, c: 2, _ } = 2
    f {a:1,b:1,c:3,d:5} + f {a:1,b:2,c:2,e:5} == 4    

    -- Tests
    -- -----
    -- By invoking javascript, we can listen for exceptions.

    err x = do! `try {
                     x();
                     return false;
                 } catch (e) {
                     return e;
                 }`

    -- Option
    -- ------

    module option
    
        type Option a = some: a | none:
        
        option b none: = b
             | _ (some: x) = x
             
        option 3 (some: 2) == 2

    module html
        ($=) x y = `if (typeof $ != 'undefined') { $(x)["html"](y); }`

    -- Lists
    -- -----
    -- A simple implementation of a library for manipulating linked lists.

    module list
    
        type List a = { head: a, tail: List a } 
                    | nil:
                
        -- This complex type can be hidden behind a constructor function which
        -- works more like a traditional cons.

        (::) x y = { head = x, tail = y }

        -- The compiler itself also supports the list sugar `[: 1, 2, 3 ]` (or
        -- `[: 1, 2, 3 :]`, if you prefer symmetry).  All of these lists are
        -- synonyms.

        let xs = [: [: 1, 2, 3 ]
                    [: 1, 2, 3 :]
                    ( 1 :: 2 :: 3 :: nil: )
                    { head: 1
                      tail: { head: 2
                              tail: { head: 3
                                      tail: nil: }}} ]

        all? (λy = [:1,2,3] == y) xs 
                           

        -- Simple implementations of list accessors, which illustrate
        -- incomplete definition.

        empty? nil: = true | _ = false

        head { head: x, tail: _ } = x
           | nil: = error "Head called on empty list"
           
        tail { head: _, tail: x } = x 
           | nil: = error "Tail called on empty list"
           
        last { head: x, tail: nil: } = x
           | { head: _, tail: x } = last x
           | nil: = error "Last called on empty list"

        take 0 _ = nil: | n x = head x :: take (n - 1) (tail x)
        drop 0 x = x | n x = drop (n - 1) (tail x)

        (..) x y when x < y = x :: (x + 1 .. y)
           | x _ = [:x]
           
        1 .. 5 == [:1,2,3,4,5]

        -- Project Euler problem 1, modified to protect the innocent:

        288045 == 1 .. 1111 |> filter (λx = x % 3 == 0 || x % 5 == 0) |> sum

        take_while f nil: = nil:
                 | f x when f (head x) = head x :: filter f (tail x)
                 | _ _ = nil:

        drop_while f nil: = nil:
                 | f x when f (head x) = drop_while f (tail x)
                 | _ x = x

        not (empty? (1 :: nil:))
        empty? [:]
   
        head [: 1, 2 ] == 1
        tail [: 1, 2 ] == [:2]
        last [: 1, 2 ] == 2

        err (lazy head nil:) == "Head called on empty list"
        err (lazy tail nil:) == "Tail called on empty list"
        err (lazy last nil:) == "Last called on empty list"

        take 2 [: 1, 2, 3 ] == [: 1, 2 ]
        drop 2 [: 1, 2, 3 ] == [: 3 ]

        take_while (λx = x < 0) [:] == [:]
        take_while (λx = x > 0) [: 2, 1, 0 ] == [: 2, 1 ]

        drop_while (λx = x < 0) nil: == nil:
        drop_while (λx = x > 0) [: 2, 1, 0 ] == [: 0 ]

        -- Cardinality
        
        length nil: = 0
             | { head: _, tail: x } = 1 + length x
             
        length [: 1, 2, 3, 4 ] == 4

        -- Generators

        init 0 _ = nil:
           | n x = x :: init (n - 1) x
           
        length (init 30 0) == 30
        tail (init 3 0)    == init 2 0

        -- List concatenation

        (++) nil: y = y
           | { head: y, tail: ys } xs = 
               y :: (ys ++ xs)

        nil: ++ (1 :: 2 :: nil:) == 1 :: 2 :: nil:
        [: 1, 2 ] ++ [: 3, 4 ] == [: 1, 2, 3, 4 ]

        -- Filter

        filter: (a -> Bool) -> List a -> List a
              | f nil: = nil:
              | f x when f (head x) = head x :: filter f (tail x)
              | f x = filter f <| tail x
                        
        filter (λx = x > 2) [: 1, 2, 3, 4 ] == [: 3, 4 ]

        -- Map

        map f nil: = nil:
          | f x = f (head x) :: map f (tail x)
          
        map (λx = x + 1) [: 1, 2, 3 ] == [: 2, 3, 4 ]
            
        -- Reverse

        reverse = 
            let r rest [:] = rest
                | rest { head: x, tail: xs } = 
                    r (x :: rest) xs

            r nil:
        
        reverse [: 1, 2, 3, 4 ] == [: 4, 3, 2, 1 ]

        -- Folds

        foldl f x xs =
            let g y nil: = y
                | y { head: z, tail: zs } = g (f y z) zs
            g x xs

        foldl1 _ nil: = error "Foldl1 called on empty list"
             | f x = foldl f (head x) (tail x)
             
        foldr f x =
            let g nil: = x
                | { head: y, tail: ys } = f y (g ys)
            g

        foldr1 _ nil: = error "Foldr1 called on empty list"
             | f x = foldr f (head x) (tail x)
             
        all? f = foldl1 (λx y = x && y) .: map f
        any? f = foldl1 (λx y = x || y) .: map f

        sum     = foldl1 (λx y = x + y)
        product = foldl1 (λx y = x * y)
        
        concat = foldl1 (λx y = x ++ y)
        concat_map f xs = concat (map f xs)
        
        maximum = foldl1 (λx y when x > y = x | _ y = y)
        minimum = foldl1 (λx y = if x > y then y else x)

        foldl (λx y = x + y) 0 [: 1, 2, 3, 4 ] == 10
        foldr (λx y = x + y) 0 [: 1, 2, 3, 4 ] == 10
        all? id [:true,true]
        not (all? id [:true,false])
        any? id [:true,false]
        not (any? id [:false,false])
        sum [:1,2,3] == 6
        product [:1,2,4] == 8

        let x = [:1,2]
            y = [:3,4]
        concat [:x,y] == [:1,2,3,4]

        concat_map (λx = [:x,x+1]) [:1,2] == [:1,2,2,3]
             
        minimum [: 1, 2, 3 ] == 1
        maximum [: 1, 2, 3 ] == 3
        

    -- Sequences
    -- ---------
    -- Sequences are an abstract data type which resembles a list, except that elements
    -- Sequences may be infinite, as long as you never try to read every element.
    -- However, the current implementation is stack-consuming and thus limited by the
    -- underlying javascript runtime [TODO].  

    module seq

        open list
        open speedtest
        open html
    
        type Seq a = seq: JS { elem: a, next: Seq a}
                   | end:
                   
        iterate f x = seq: do ret { elem: x, next: iterate f (f x) }

        from_list nil: = end:
                | { head: x, tail: xs } =
                    seq: do ret { elem: x, next: from_list xs }
                    
        to_list end: = nil:
              | { seq: x } = do! { elem: y, next: ys } <- x
                                 ret (y :: to_list ys)

        take _ end: = end:
           | 0 _ = end:
           | x { seq: y } = seq: do { elem: z, next: zs } <- y
                                    ret { elem: z, next: take (x - 1) zs }

        to_list (from_list [:1,2]) == [:1,2]
        iterate (λx = x + 1) 0 |> take 500 |> to_list |> length == 500

        zip_with:
        
              (a -> b -> c) -> Seq a -> Seq b -> Seq c
            | _ end:     _        = end:
            | _ _        end:     = end:
            | f {seq: a} {seq: b} =

                seq: do { elem: xx, next: xs } <- a
                        { elem: yy, next: ys } <- b

                        ret { elem: f xx yy, next: zip_with f xs ys }
                                        
        (:::) x y = seq: do ret { elem: x, next: do! y }
        
        tail:
              Seq a   -> Seq a
            | end:     = error "tail called on empty seq"
            | {seq: t} = do! t >>= λx = ret x.next
 
        to_lazy end: = end:
              | {seq: y} = seq: lazy do! { elem: x, next: xs } <- y
                                         ret { elem: x, next: to_lazy xs }
 
        -- Infinite sequence example
 
        fibs = to_lazy (1 ::: do ret (1 ::: do ret (zip_with (λx y = x + y) fibs (tail fibs))))
    
        -- Since the `lazy` keyword memoizes it's argument, this fibonacci implementation
        -- is ridiculously faster than the recursive version.  For example, the runtime
        -- speed of this fib implementation compared to the native recursive one is <span
        -- id="speedtest">__________</span>% (filled in dynamically).

        do! fast_time <- time do ret (fast_fib 35)
            slow_time <- time do ret (fibs |> take 35 |> to_list |> last)
            let ratio = floor (fast_time / slow_time * 100)
            "#speedtest" $= ratio
            ret (ratio >= 10)

        fibs |> take 5 |> to_list == [:1,1,2,3,5]

        fast_fib 35 == fibs |> take 35
                            |> to_list
                            |> last

    module functor

        open list
                                
        type Functor f = { map: (a -> b) -> f a -> f b }

        list_functor = { map f { head: x, tail: xs } = { head: f x, tail: list_functor.map f xs }
                             | _ nil: = nil: }

        other_functor = { map f {x: x} = {x: f x } }

        map { map: m } x f = m f x 
