
Formal Prelude
==============

* * *

Formal is a functional programming language which targets Javascript.
Designed for readability and compiler verification, Formal is
powerful, flexible and easy to learn.

    module prelude

Bootstrap
---------
Some simple reflection by lifting from Javascript.  The definitions of
`object?` and `array?` must use Javascript's `===` operator directly
here, as the "==" operator defined in [Numbers](#numbers) is defined
in terms of them.

        object? x = run `typeof x === "object"`
        array? = is_array
        
        not x = run `!x`
        
        object? {}
        array? []

        not false
        not (array? {})
        not (object? 0)

Side effects can only happen in Javascript, so we use a monadic container to
compose these bits.

        run x = x null

        (>>=) x y = lazy run (y (run x))
        ret x     = lazy x
        (>>) x y  = `x(); return y();`
        
        log x = `console.log(x)`

        run (do x <- `1 + 4`
                y <- `2 + 3`
                log ("x is " + x + " and y is " + y)
                ans <- `x + y`
                ret (10 == ans))
                  
        run (ret 5) == 5
        run (log "test" >> `5 + 5`) == 10
        
        time js =

            do start <- `new Date().getTime()`
               js
               stop <- `new Date().getTime()`
               ret (stop - start)

Numbers
-------
Some basic aliases to native javascript infix functions.

        (&&) x y = run `x && y`
        (||) x y = run `x || y`
        (*)  x y = run `x * y`
        (/)  x y = run `x / y`
        (+)  x y = run `x + y`
        (-)  x y = run `x - y`
        (<=) x y = run `x <= y`
        (>=) x y = run `x >= y`
        (<)  x y = run `x < y`
        (>)  x y = run `x > y`

Equality is overloaded to match records and arrays

        (==) x y when object? x && object? y =
               let result = true
               run `for (key in x) {
                        result = result && _eq_eq(x[key])(y[key]);
                    };
                    return result;`
           | x y when array? x && array? y =
               let result = true
               run `for (z in x) {
                        result = result && _eq_eq(x[z])(y[z]);
                    };
                    return (result && x.length == y.length);`
           | x y = run `x === y`
                 
        (!=) x y = not (x == y)
        
And a few simple tests to verify the correctness of these
implementations.  This is not meant to be exhaustive, only a smoke
test against regressions.

        (3 * 4) + 5 * 4 == 64 / 2
        4 - 1 != 5 - 10
        (10 >= 5 + 5) != (4 + 5 <= 10 - 2)
        ({test: 1} == {test: 1}) == true
        ({test: 1} != {test: 1}) == false

Fibonacci function

        fib 0 = 0 | 1 = 1 | n = fib (n - 1) + fib (n - 2)

Due to the nested recursion, this is an excellent function for testing the
runtime speed versus raw javascript.  `fast_fib` is a trivial javascript
implementation of the same function, recursed itself to remove any potential
overhead from formal's dispatch mechanism.

        module speedtest

            fast_fib = run `var f = function(n) {
//                                n === 0 ? 0 : n === 1 ? 1 : f(n - 1) + f(n - 2)  
            
                                if (n === 0) {
                                    return 0;
                                } else if (n === 1) {
                                    return 1;
                                } else {
                                    return f(n - 1) + f(n - 2)
                                };
                            };
                            return f;`
                    
            fast_fib 7 == fib 7
            
With this, we can set up a simple canary to elt us know if the prelude is
suddenly dramatically slower than it reviously was; in this case, we fail a test
if the formal version isn't at least 90% as fast as the native javascript
version.

            floor = run `Math.floor`
         
            run <: do fast_time <- time (lazy fast_fib 35)
                      slow_time <- time (lazy fib 35)
                      let ratio = floor <| fast_time / slow_time * 100
                      log ("Runtime speed ~" + ratio + "%")
                      ret (ratio >= 50)

Function Combinators
--------------------
Simple left & right pipes, ala F#.  

        (<|) x y = x y
        (|>) x y = y x
        
        3 |> (\y = y + 1) |> (\y = y + 1)    == 5
        (\y x z = x + y + z + 1) 1 <| 3 <| 4 == 9
        
Alternatively, there is a right associative version of `<|`, ala
haskell.  All operators which end with a `:` are right associative.

        (<:) x y = x y
        
        (\x = x - 3) <: (\x = x - 3) <: 5 + 5 == 4
        
Function composition

        (.:) x y = \z = x (y z)
        id x = x
        flip f a b = f b a
        
        ((\x = x + 1) .: (\x = x * 2) .: (\x = x - 3)) 4 == 3
        id [1, 2, 3] == [1, 2, 3]
        flip (\x y = x - y) 3 5 == 2



Tests
-----
By invoking javascript, we can listen for exceptions.

        err x = run `try {
                         x();
                         return false;
                     } catch (e) {
                         return e;
                     }`



Option
------
        
        type Option a = some: a | none:
        
        option b nil: = b
             | _ (some: x) = x
             
        option 3 (some: 2) == 2


Lists
-----
A simple implementation of a library for manipulating linked lists.

        module list
        
            type List a = cons: { head: a, tail: List a } 
                          | nil:
            
This complex type can be hidden behind a constructor function which
works more like a traditional cons.

            (::) x y = cons: { head = x, tail = y }
            
            1 :: 2 :: nil: == 1 :: 2 :: nil:
            nil: :: nil:   == cons: { head = nil:, tail = nil: }
            3 :: 4 :: nil: ==

                cons: { head: 3
                        tail: cons: { head: 4
                                      tail: nil: }}

Simple implementations of list accessors, which illustrate
incomplete definition.

            empty? nil: = true | _ = false

            head (cons: { head: x }) = x | nil: = error "Head called on empty list"
            tail (cons: { tail: x }) = x | nil: = error "Tail called on empty list"
            last (cons: { head: x, tail: nil: }) = x
               | (cons: { tail: x }) = last x
               | nil: = error "Last called on empty list"

            take 0 _ = nil: | n x = head x :: take (n - 1) (tail x)
            drop 0 x = x | n x = drop (n - 1) (tail x)


            not (empty? (1 :: nil:))
            empty? (nil:)
   
            head (1 :: 2 :: nil:)  == 1
            tail (1 :: 2 :: nil:)  == 2 :: nil:
            last (1 :: 2 :: nil:)  == 2
            err (lazy head (nil:)) == "Head called on empty list"
            err (lazy tail (nil:)) == "Tail called on empty list"
            err (lazy last (nil:)) == "Last called on empty list"

            take 2 (1 :: 2 :: 3 :: nil:) == 1 :: 2 :: nil:
            drop 2 (1 :: 2 :: 3 :: nil:) == 3 :: nil:


Cardinality
            
            length nil: = 0
                 | (cons: { tail: x }) = 1 + length x
                 
            length (1 :: 2 :: 3 :: 4 :: nil:) == 4

Generators

            init 0 _ = nil:
               | n x = x :: init (n - 1) x
               
            length (init 30 0) == 30
            tail (init 3 0)    == init 2 0

List concatenation

            (++) nil: y = y
               | (cons: { head: y, tail: ys }) xs = 
                   y :: (ys ++ xs)
            
            nil: ++ (1 :: 2 :: nil:) == 1 :: 2 :: nil:
            (1 :: 2 :: nil:) ++ (3 :: 4 :: nil:) == 
                1 :: 2 :: 3 :: 4 :: nil:

Filter

            filter f nil: = nil:
                 | f x when f (head x) = head x :: filter f (tail x)
                 | f x = filter f <| tail x
                            
            filter (\x = x > 2) (1 :: 2 :: 3 :: 4 :: nil:) == 3 :: 4 :: nil:

Map

            map f nil: = nil:
              | f x = f (head x) :: map f (tail x)
              
            map (\x = x + 1) (1 :: 2 :: 3 :: nil:) == 
                2 :: 3 :: 4 :: nil:
                
Reverse

            reverse = 
                let r rest nil: = rest
                    | rest (cons: { head: x, tail: xs }) = 
                        r (x :: rest) xs

                r (nil:)
            
            reverse (1 :: 2 :: 3 :: 4 :: nil:) ==
                4 :: 3 :: 2 :: 1 :: nil:

Folds

            foldl f x xs =
                let g y nil: = y
                    | y (cons: { head: z, tail: zs }) = g (f y z) zs
                g x xs

            foldl1 _ nil: = error "Foldl1 called on empty list"
                 | f x = foldl f (head x) (tail x)
                 
            foldr f x =
                let g nil: = x
                    | (cons: { head: y, tail: ys }) = f y (g ys)
                g

            foldr1 _ nil: = error "Foldr1 called on empty list"
                 | f x = foldr f (head x) (tail x)
                 
            all? f = foldl1 (\x y = f x && f y)
            any? f = foldl1 (\x y = f x || f y)

            sum     = foldl1 (\x y = x + y)
            product = foldl1 (\x y = x * y)
            
            concat = foldl1 (\x y = x ++ y)
            concat_map f xs = concat (map f xs)
            
            maximum = foldl1 (\x y = if x > y then x else y)
            minimum = foldl1 (\x y = if x > y then y else x)

            foldl (\x y = x + y) 0 (1 :: 2 :: 3 :: 4 :: nil:) == 10
            foldr (\x y = x + y) 0 (1 :: 2 :: 3 :: 4 :: nil:) == 10
            all? id (true :: true :: nil:)
            not (all? id (true :: false :: nil:))
            any? id (true :: false :: nil:)
            not (any? id (false :: false :: nil:))
            sum (1 :: 2 :: 3 :: nil:) == 6
            product (1 :: 2 :: 4 :: nil:) == 8

            concat ((1 :: 2 :: nil:) :: (3 :: 4 :: nil:) :: nil:) ==
                1 :: 2 :: 3 :: 4 :: nil:

            concat_map (\x = (x :: x + 1 :: nil:)) (1 :: 2 :: 3 :: 4 :: nil:) ==
                 1 :: 2 :: 2 :: 3 :: 3 :: 4 :: 4 :: 5 :: nil:
                 
            minimum (1 :: 2 :: 3 :: nil:) == 1
            maximum (1 :: 2 :: 3 :: nil:) == 3
            


Sequences
---------
Sequences are an abstract data type which resembles a list, except that elemnts
of a sequence are constructed lazily as they are requested.

        module sequence
        
            open list

            type Seq a = Js ( { val: a, next: Seq a } | end: )

Converting a `List` to a `Seq` is simple and O(1) as the list need not be walked

            from_list nil: = lazy end:
                    | x    = lazy { val: head x, next: from_list (tail x) }

... but converting back is not.


            to_list =
                let f { val: x, next: xs } = x :: to_list xs
                    | end: = nil:
                f .: run

            to_list (from_list (1 :: 2 :: nil:)) == 1 :: 2 :: nil:

Sequences may be infinite, as long as you never try to read every element.
However, the current implementation is stack-consuming and thus limited by the
underlying javascript runtime ...

            iterate f x = lazy { val: x, next: iterate f (f x) } 

            take 0 _ = lazy end:
               | n x = do y <- x
                          ret (y |> \ end: = end:
                                    | { val: y, next: ys } = 
                                        { val: y
                                          next: take (n - 1) ys })
                                           
            1 :: 2 :: 3 :: nil: == 
                (1 :: 2 :: 3 :: 4 :: nil:) |> from_list 
                                           |> take 3
                                           |> to_list

            500 == iterate (\x = x + 1) 0
                   |> take 500
                   |> to_list
                   |> length
                        



Maps
----

        module map
            
            type Map a b = map: Array { key: a, val: b }
            
            (%) x y = { key = x, val = y }
            
            "test" % true == { key = "test", val = true }


    open prelude
