
Sonnet
======
A programming language, designed to be read

* * *

Sonnet is:

*  functional, pure, statically type inferred, eagerly evaluated
*  flexible syntax that's simple and easy on the eyes
*  targets V8 Javascript (Chrome & Node.js), Closure Advanced
*  first class syntax for Javascript, JSON & HTML
*  first class syntax for assertions & invariant style testing ala QuickCheck,
   compiler by default generate Jasmine suite
*  standard lib for events, lazy sequences & comprehensions
*  directly inspired by Haskell, F#, OCAML, Coffeescript, Clojure, Scala

Values and Types
--------------------------------------------------------------------------------

Anonymous JSON:

    type Unit = {}   

    type Complex = { real: Num, img: Num }

Named JSON - this is basically a special function that takes an anonymous JSON
as an argument and returns the same value of a new type, with the option of ignoring
the `{}` in such values which take a `Unit` type as an argument.

    type Point = point: { x: Num, y: Num }

    type Unitt = unit: {}  

Union JSON - which is simply a set of any of the above or of the native
JSON types, separated by either new lines w/indentation, or `|`

    type Option a = some: a | none: {}

    type Bool = true: | false:


Polymorphic JSON, which are any of the above with an introduction of a some
type variables into scope: 

    type List a = 
        | cons: { h: a, t: List a }
        | nil:

    type T a b = T of { a: a, b: b } 

    type Map key value =
        | from_list: { items: List (T key value) }
        | empty:

    mult { x = real, y = img } { u = real, v = img } = 
         { real = x * u - y * v, img = x * v - y * u }  

   -- Alternatively:
   -- mult | x y = { real = x.real * y.real - x.img * y.img
   --                img =  x.real * y.img - x.img * y.real }

Inherited JSON, which is polymorphic to the type it inherits from, and is declared
using the `with` keyword:

    type Semigroup a = { zero: a }

    type Monoid a = { Semigroup with plus: a → a → a }



Definitions
--------------------------------------------------------------------------------
Modules define a scope for a collection of definitions.  Nesting modules is
allowed, but only when the nesting is explicit via indentation.

   module List

Definitions are specified via `=`, types via `:`, and assertions via `?`.  A 
definition must be named once, and defines an indented scope for further 
specifiers.  These may redeclare their scope if preferred.
 
   --- Returns the first element of a list
    head: List a → a
        | nil    = undefined -- head is not defined for an empty list.   


JSON may also be destructed positionally if all keys are accounted for:

    tail: 

        List a → a
      | (cons -> { tail = 4 }) = x
      | []       = undefined 

      tail [3] == 3
      tail [5, 1, 2] == [1, 2]

    cons: List a -> { head: a, tail: List a }

    --- Applies f recursively from the last element of the list.  Consumes 
    --  much stack (Haskell style)

    foldr:  (a → b → a) → b → List a → b
    | f x [] = x
    | f x (cons->{head=y,tail=ys}) = f y (foldr f x ys) 

    length:
    --- Returns the cardinality of a list (mixed style)

        List a    → Int
      | []        = 0
      | [_, xs] = 1 + length xs

    length [] == 0
    length [1] == 1
    length [1, 3, 2, 4] == 4

Though comments are defined via --, the alternative --- defines metadata in the
form of a string which applies to the previous symbol.  The use of undefined above
logs its metadata when it is evaluated, and provides documentation for the
function itself.

Anonymous functions may be declared with `λ` in two different forms, via pattern 
match (haskell-style) or via variable "templating" (clojure style):

    tail = λ (cons -> {tail = y}) = y
           | []      = undefined

or via variable "templating" (clojure style):

    --fmap (λ_ + 1) [1 2 3] ? [2 3 4] 

Assertions
--------------------------------------------------------------------------------
Assertions can be declared simply by writing an expression which evaluates to a
boolean.  Assertions are compiled to a seperate file (____.tests.js), but
included in the genreated documentation, such that loading the documentation
(_____.html) runs the test suite and prints the results at the bottom.

    filter: (a -> bool) -> List a -> List a
          | f [] = []
          | f (cons->{head=x,tail=xs}) = append (f x) (filter f xs)

    filter (\x = x < 2) [0, 1, 3, 4, 1, 4] == [0, 1, 1]


Patterns
--------------------------------------------------------------------------------

    type ReverseList a = reverse_list: List a

    reverse (cons -> {head=x,tail=xs}) = reverse xs + x | [] = []

    last: List a            → a
        | (reverse -> (cons -> {head=x})) = x
        | _ = undefined

    type Parity = even: | odd:

    length_parity (cons -> {tail=(length_parity -> even)}) = odd | _ = even    

    length_parityy (cons -> {tail=xs}) = ap (length_parity xs) (\ even: = odd: | _ = even:)

Implicits
--------------------------------------------------------------------------------
Any definition may be marked as implicit, which simply means that if the type
checker fails, the compiler will attempt to "fill in" parameters marked implicit
with a unique instance in scope.  For example, Haskell's Show type class can be
easily implemented as a function with an implicit return type:

    ____: 

        Complex          -> Str
      | x when x.img == 0 = string x.real
      | x when x.img > 0  = string x.real + " + " + x.img + "i"
      | x                 = string x.real + " - " + x.img + "i"
        
The `___` makes this function implicit; it is by extension uninvokable by name.
As there is now a unique implicit instance of a function which converts
`Complex` to `Str`, we may now use `Complex` types in places where we would
otherwise use a string:

    length { real = 2.0, img = 3.0 } == 10
    
Implicit parameters other than the return type may be optionally left out of the
function invocation - as long as there is a unique instance in scope which
satisfies the type signature, it will be inserted automatically.

    type Class a = (a -> b) -> b

    ___ : (class: a) -> Class a 
        | x             f = f x

    type Functor f = { map: (a -> b) -> f a -> f b }

    ___: Class (Functor List) = class:

         { map = \ f (cons->{head=x,tail=xs}) = append [f x] (mapp f xs)
                 | f [] = [] }

    map | f = f.map

    incF: (class: Functor f) -> f Int → f Int
        | functor                 g   = functor.map inc m

    fmap func (comp f g) x == fmap func f (fmap func g x)
    fmap func id x == x
    
      
There is a single instance of Functor List in scope (even though it
has no name), so fmap can be invoked on lists with no Functor param

    fmap (\ x = x + 1) [1, 2, 3] == [2, 3, 4]    

Here's a few sample Haskell type classes encoded as regular ADTs, then
instantiated such that they may be useful as implicit parameters:                            
              
    type Applicative f =

        { Functor f with
              return: a → f a,
              ap:    f (a → b) → f a → f b }
  
    f | x = x ** 1

    applicative = abstract: { map = \f x = return f * x }  

  --  forall u v w x y 	
 
        return id * v == v f                        -- Identity
        return comp ** u ** v ** w == u ** (v ** w) -- Composition
        return f ** return x == return (f x)       -- Homomorphism
        u ** return y == return (\ f = f y) ** u       -- Interchange      

    type Monad m =

        { Applicative m with
              bind: m a → (a → m b) → m b,
              join: m (m a) → m a }

    monad = abstract:

        { applicative with
              ap = \x y = x >>= (\ f = map f y)
              bind = \ x y = join (map f x)
              join = \x = x >>= id }
        
    return x >>= f == f x                   -- Left identity
    x >>= return == x                       -- Right identity              
    (f >>= g) >>= h == f >>= (\ x = g x >>= h)  -- Commutatative 

Since the type of this instance is inferable and we aren't naming it, we can 
declare instance simply like this:

    { zero         = []
      (x :: y) + z = x :: (y + z)
      []       + x = x }

    ? zero + [1] + zero = [1]
    ? [2 3] + zero + [1] = [2 3 1]

Though in some cases, we may want to give it a name and or type annotation:
    
    list_monad =

        { monad with 
              return x = [x]
              xs >>= f = reduce (λ_ + _) (map f y)
              [] >>= f = zero }
     
    map list_monad fib [] == zero
    map list_monad fib [0 1] == [1 1]
    map list_monad fib [6] == [13]
    map list_monad fib [2 3 4 5] == [1 2 3 5]
        
Javascript & HTML
--------------------------------------------------------------------------------
Sonnet's standard IO library covers many common browser & node.js libraries, but
the language itself has no support for IO per se.  Rather, side effects are only
allowed to occur in quoted javascript, which has slightly different rules than 
standard javascript, but compiles into basically what you expect.

    log: Str → !
    log x = `console.log(x)`

The return type of any quoted javascript is a special IO type `a!`, where a is
inferred to be `()` when not provided.

    io_monad: Monad !
        = { return x = `function() { return x }`
            x >>= f  =  `f(x())` }

    module JQuery
    --  Library of useful JQuery wrappers

        set_html:
        --  Sets nodes which match id to html

            Str → Str  → !
          | id    html = `$(id).html(html)`

        get_html:
        --  Gets the html context of node id

            Str → Str!
          | id  = `$(id).html()`

             
Side effects types via !, implicit monadic composition

        copy_html:

            Str → Str → !
          | id1    id2  = x ← get_html id1
                          set_html id2 x

        copy_html' id1 id2 = get_html id1 >>= set_html id2

        -- _ binds to the nth parameter of the
        -- nearest function scope

        copy_html'' = join . map (set_html _) . get_html

    module Atom
    
        type Atom a = { get: a!, set: a → ! }
        
        new: a → Atom! a
        new x = `function(){var y=x;return {get:function(){return y},set:function(z){y=z}}}`

        get: Atom a → a!
        get x = `x.get()`
        
        swap: Atom a → (a → Option a) → a!
        swap a f = x ← `a.get()`
                   match f x with 
                         none → return x
                         some x → `a.set(x)`
                                   return x 

        atom_monad: Monad Atom! =         
            { return = new
              x >>= f = x >>= λ get _ >>= f }
              



