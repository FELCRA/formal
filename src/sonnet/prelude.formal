
Formal Prelude
==============

* * *

Formal is a functional programming language which targets Javascript.
Designed for readability and compiler verification, Formal is
powerful, flexible and easy to learn.

    module prelude

Bootstrap
---------
Some simple reflection by lifting from Javascript.  The definitions of
`object?` and `array?` must use Javascript's `===` operator directly
here, as the "==" operator defined in [Numbers](#numbers) is defined
in terms of them.

        object? x = `typeof x === "object"`
        array? = is_array
        
        not x = `!x`
        
        object? {}
        array? []

        not false
        not (array? {})
        not (object? 0)

Numbers
-------
Some basic aliases to native javascript infix functions.

        (&&) x y = `x && y`
        (||) x y = `x || y`
        (*)  x y = `x * y`
        (/)  x y = `x / y`
        (+)  x y = `x + y`
        (-)  x y = `x - y`
        (<=) x y = `x <= y`
        (>=) x y = `x >= y`
        (<)  x y = `x < y`
        (>)  x y = `x > y`

Equality is overloaded to match records and arrays

       (==) x y when object? x && object? y =
               let result = `true`
               `for (key in x) {
                    result = result && _eq_eq(x[key])(y[key]);
               };
               return result;`
           | x y when array? x && array? y =
               let result = `true`
               `for (z in x) {
                    result = result && _eq_eq(x[z])(y[z]);
                };
                return (result && x.length == y.length);`
           | x y = `x === y`
                 
        (!=) x y = not (x == y)
        
And a few simple tests to verify the correctness of these
implementations.  This is not meant to be exhaustive, only a smoke
test against regressions.

        (3 * 4) + 5 * 4 == 64 / 2
        4 - 1 != 5 - 10
        (10 >= 5 + 5) != (4 + 5 <= 10 - 2)
        ({test: 1} == {test: 1}) == `true`
        ({test: 1} != {test: 1}) == `false`

Fibonacci function

        fib 0 = 0 | 1 = 1 | n = fib (n - 1) + fib (n - 2)



Function Combinators
--------------------
Simple left & right pipes, ala F#.  

        (<|) x y = x y
        (|>) x y = y x
        
        3 |> (\y = y + 1) |> (\y = y + 1)    == 5
        (\y x z = x + y + z + 1) 1 <| 3 <| 4 == 9
        
Alternatively, there is a right associative version of `<|`, ala
haskell.  All operators which end with a `:` are right associative.

        (<:) x y = x y
        
        (\x = x - 3) <: (\x = x - 3) <: 5 + 5 == 4
        
Function composition

        (.:) x y = \z = x (y z)
        id x = x
        flip f a b = f b a
        
        ((\x = x + 1) .: (\x = x + 2) .: (\x = x + 3)) 4 == 10
        id [1, 2, 3] == [1, 2, 3]
        flip (\x y = x - y) 3 5 == 2



Tests
-----
By invoking javascript, we can listen for exceptions.

        err x = `try {
                     x();
                     return false;
                 } catch (e) {
                     return e;
                 }`



Option
------
        
        type Option a = some: a | none:
        
        option b nil: = b
             | _ (some: x) = x
             
        option 3 (some: 2) == 2


Lists
-----
A simple implementation of a library for manipulating linked lists.

        module list
        
            type List a = cons: { head: a, tail: List a } 
                          | nil:
            
This complex type can be hidden behind a constructor function which
works more like a traditional cons.

            (::) x y = cons: { head = x, tail = y }
            
            1 :: 2 :: nil: == 1 :: 2 :: nil:
            nil: :: nil:   == cons: { head = nil:, tail = nil: }
            3 :: 4 :: nil: ==

                cons: { head: 3
                        tail: cons: { head: 4
                                      tail: nil: }}

Simple implementations of list accessors, which illustrate
incomplete definition.

            empty? nil: = `true` | _ = `false`

            head (cons: { head: x }) = x | nil: = error "Head called on empty list"
            tail (cons: { tail: x }) = x | nil: = error "Tail called on empty list"
            last (cons: { head: x, tail: nil: }) = x
               | (cons: { tail: x }) = last x
               | nil: = error "Last called on empty list"

            take 0 _ = nil: | n x = head x :: take (n - 1) (tail x)
            drop 0 x = x | n x = drop (n - 1) (tail x)


            module accessortests
                not (empty? (1 :: nil:))
   
                head (1 :: 2 :: nil:) == 1
                tail (1 :: 2 :: nil:) == 2 :: nil:
                last (1 :: 2 :: 3 :: nil:) == 3
            
                err (\_ = head (nil:)) == "Head called on empty list"
                err (\_ = tail (nil:)) == "Tail called on empty list"
                err (\_ = last (nil:)) == "Last called on empty list"

                take 2 (1 :: 2 :: 3 :: 4 :: nil:) == 1 :: 2 :: nil:
                drop 2 (1 :: 2 :: 3 :: nil:) == 3 :: nil:


Cardinality
            
            length nil: = 0
                 | (cons: { tail: x }) = 1 + length x
                 
            length (1 :: 2 :: 3 :: 4 :: nil:) == 4

Generators

            init 0 _ = nil:
               | n x = x :: init (n - 1) x
               
            length (init 30 0) == 30
            tail (init 3 0)    == init 2 0

List concatenation

            (++) nil: y = y
               | (cons: { head: y, tail: ys }) xs = y :: (ys ++ xs)
            
            nil: ++ (1 :: 2 :: nil:) == 1 :: 2 :: nil:
            (1 :: 2 :: nil:) ++ (3 :: 4 :: nil:) == 
                1 :: 2 :: 3 :: 4 :: nil:

Filter

            filter f nil: = nil:
                 | f x when f (head x) = head x :: filter f (tail x)
                 | f x = filter f <| tail x
                            
            filter (\x = x > 2) (1 :: 2 :: 3 :: 4 :: nil:) == 3 :: 4 :: nil:

Map

            map f nil: = nil:
              | f x = f (head x) :: map f (tail x)
              
            map (\x = x + 1) (1 :: 2 :: 3 :: nil:) == 
                2 :: 3 :: 4 :: nil:
                
Reverse

            reverse = 
                let r rest nil: = rest
                    | rest (cons: { head: x, tail: xs }) = 
                        r (x :: rest) xs

                r (nil:)
            
            reverse (1 :: 2 :: 3 :: 4 :: nil:) ==
                4 :: 3 :: 2 :: 1 :: nil:


Maps
----

        module map
            
            type Map a b = map: Array { key: a, val: b }
            
            (%) x y = { key = x, val = y }
            
            "test" % true: == { key = "test", val = true: }


    open prelude
