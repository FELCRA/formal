
Formal Prelude
==============

* * *

Formal is a functional programming language which targets Javascript.
Designed for readability and compiler verification, Formal is
powerful, flexible and easy to learn.

    module prelude

Bootstrap
---------
Some simple reflection by lifting from Javascript.  The definitions of
`object?` and `array?` must use Javascript's `===` operator directly
here, as the "==" operator defined in [Numbers](#numbers) is defined
in terms of them.

        object? x = run `typeof x === "object"`
        array? = is_array
        
        not x = run `!x`
        
        object? {}
        array? []

        not false
        not (array? {})
        not (object? 0)

Side effects can only happen in Javascript, so we use a monadic container to
compose these bits.

        run x = x null

        (>>=) x y = `y(run(x))()`
        ret x = `x`

        10 == run (do x <- `1 + 4`
                      y <- `2 + 3`
                      `console.log("x is " + x + " and y is " + y)`
                      `x + y`)
                  
        run (ret 5) == 5

Numbers
-------
Some basic aliases to native javascript infix functions.

        (&&) x y = run `x && y`
        (||) x y = run `x || y`
        (*)  x y = run `x * y`
        (/)  x y = run `x / y`
        (+)  x y = run `x + y`
        (-)  x y = run `x - y`
        (<=) x y = run `x <= y`
        (>=) x y = run `x >= y`
        (<)  x y = run `x < y`
        (>)  x y = run `x > y`

Equality is overloaded to match records and arrays

        (==) x y when object? x && object? y =
               let result = true
               run `for (key in x) {
                        result = result && _eq_eq(x[key])(y[key]);
                    };
                    return result;`
           | x y when array? x && array? y =
               let result = true
               run `for (z in x) {
                        result = result && _eq_eq(x[z])(y[z]);
                    };
                    return (result && x.length == y.length);`
           | x y = run `x === y`
                 
        (!=) x y = not (x == y)
        
And a few simple tests to verify the correctness of these
implementations.  This is not meant to be exhaustive, only a smoke
test against regressions.

        (3 * 4) + 5 * 4 == 64 / 2
        4 - 1 != 5 - 10
        (10 >= 5 + 5) != (4 + 5 <= 10 - 2)
        ({test: 1} == {test: 1}) == true
        ({test: 1} != {test: 1}) == false

Fibonacci function

        fib 0 = 0 | 1 = 1 | n = fib (n - 1) + fib (n - 2)



Function Combinators
--------------------
Simple left & right pipes, ala F#.  

        (<|) x y = x y
        (|>) x y = y x
        
        3 |> (\y = y + 1) |> (\y = y + 1)    == 5
        (\y x z = x + y + z + 1) 1 <| 3 <| 4 == 9
        
Alternatively, there is a right associative version of `<|`, ala
haskell.  All operators which end with a `:` are right associative.

        (<:) x y = x y
        
        (\x = x - 3) <: (\x = x - 3) <: 5 + 5 == 4
        
Function composition

        (.:) x y = \z = x (y z)
        id x = x
        flip f a b = f b a
        
        ((\x = x + 1) .: (\x = x + 2) .: (\x = x + 3)) 4 == 10
        id [1, 2, 3] == [1, 2, 3]
        flip (\x y = x - y) 3 5 == 2



Tests
-----
By invoking javascript, we can listen for exceptions.

        err x = run `try {
                         x();
                         return false;
                     } catch (e) {
                         return e;
                     }`



Option
------
        
        type Option a = some: a | none:
        
        option b nil: = b
             | _ (some: x) = x
             
        option 3 (some: 2) == 2


Lists
-----
A simple implementation of a library for manipulating linked lists.

        module list
        
            type List a = cons: { head: a, tail: List a } 
                          | nil:
            
This complex type can be hidden behind a constructor function which
works more like a traditional cons.

            (::) x y = cons: { head = x, tail = y }
            
            1 :: 2 :: nil: == 1 :: 2 :: nil:
            nil: :: nil:   == cons: { head = nil:, tail = nil: }
            3 :: 4 :: nil: ==

                cons: { head: 3
                        tail: cons: { head: 4
                                      tail: nil: }}

Simple implementations of list accessors, which illustrate
incomplete definition.

            empty? nil: = true | _ = false

            head (cons: { head: x }) = x | nil: = error "Head called on empty list"
            tail (cons: { tail: x }) = x | nil: = error "Tail called on empty list"
            last (cons: { head: x, tail: nil: }) = x
               | (cons: { tail: x }) = last x
               | nil: = error "Last called on empty list"

            take 0 _ = nil: | n x = head x :: take (n - 1) (tail x)
            drop 0 x = x | n x = drop (n - 1) (tail x)


            not (empty? (1 :: nil:))
            empty? (nil:)
   
            head (1 :: 2 :: nil:) == 1
            tail (1 :: 2 :: nil:) == 2 :: nil:
            last (1 :: 2 :: 3 :: nil:) == 3
            err (\_ = head (nil:)) == "Head called on empty list"
            err (\_ = tail (nil:)) == "Tail called on empty list"
            err (\_ = last (nil:)) == "Last called on empty list"

            take 2 (1 :: 2 :: 3 :: 4 :: nil:) == 1 :: 2 :: nil:
            drop 2 (1 :: 2 :: 3 :: nil:) == 3 :: nil:


Cardinality
            
            length nil: = 0
                 | (cons: { tail: x }) = 1 + length x
                 
            length (1 :: 2 :: 3 :: 4 :: nil:) == 4

Generators

            init 0 _ = nil:
               | n x = x :: init (n - 1) x
               
            length (init 30 0) == 30
            tail (init 3 0)    == init 2 0

List concatenation

            (++) nil: y = y
               | (cons: { head: y, tail: ys }) xs = 
                   y :: (ys ++ xs)
            
            nil: ++ (1 :: 2 :: nil:) == 1 :: 2 :: nil:
            (1 :: 2 :: nil:) ++ (3 :: 4 :: nil:) == 
                1 :: 2 :: 3 :: 4 :: nil:

Filter

            filter f nil: = nil:
                 | f x when f (head x) = head x :: filter f (tail x)
                 | f x = filter f <| tail x
                            
            filter (\x = x > 2) (1 :: 2 :: 3 :: 4 :: nil:) == 3 :: 4 :: nil:

Map

            map f nil: = nil:
              | f x = f (head x) :: map f (tail x)
              
            map (\x = x + 1) (1 :: 2 :: 3 :: nil:) == 
                2 :: 3 :: 4 :: nil:
                
Reverse

            reverse = 
                let r rest nil: = rest
                    | rest (cons: { head: x, tail: xs }) = 
                        r (x :: rest) xs

                r (nil:)
            
            reverse (1 :: 2 :: 3 :: 4 :: nil:) ==
                4 :: 3 :: 2 :: 1 :: nil:

Folds

            foldl f x xs =
                let g y nil: = y
                    | y (cons: { head: z, tail: zs }) = g (f y z) zs
                g x xs

            foldl1 _ nil: = error "Foldl1 called on empty list"
                 | f x = foldl f (head x) (tail x)
                 
            foldr f x =
                let g nil: = x
                    | (cons: { head: y, tail: ys }) = f y (g ys)
                g

            foldr1 _ nil: = error "Foldr1 called on empty list"
                 | f x = foldr f (head x) (tail x)
                 
            all? f = foldl1 (\x y = f x && f y)
            any? f = foldl1 (\x y = f x || f y)

            sum     = foldl1 (\x y = x + y)
            product = foldl1 (\x y = x * y)
            
            concat = foldl1 (\x y = x ++ y)
            concat_map f xs = concat (map f xs)
            
            maximum = foldl1 (\x y = if x > y then x else y)
            minimum = foldl1 (\x y = if x > y then y else x)

            foldl (\x y = x + y) 0 (1 :: 2 :: 3 :: 4 :: nil:) == 10
            foldr (\x y = x + y) 0 (1 :: 2 :: 3 :: 4 :: nil:) == 10
            all? id (true :: true :: nil:)
            not (all? id (true :: false :: nil:))
            any? id (true :: false :: nil:)
            not (any? id (false :: false :: nil:))
            sum (1 :: 2 :: 3 :: nil:) == 6
            product (1 :: 2 :: 4 :: nil:) == 8

            concat ((1 :: 2 :: nil:) :: (3 :: 4 :: nil:) :: nil:) ==
                1 :: 2 :: 3 :: 4 :: nil:

            concat_map (\x = (x :: x + 1 :: nil:)) (1 :: 2 :: 3 :: 4 :: nil:) ==
                 1 :: 2 :: 2 :: 3 :: 3 :: 4 :: 4 :: 5 :: nil:
                 
            minimum (1 :: 2 :: 3 :: nil:) == 1
            maximum (1 :: 2 :: 3 :: nil:) == 3
            
                
            




Maps
----

        module map
            
            type Map a b = map: Array { key: a, val: b }
            
            (%) x y = { key = x, val = y }
            
            "test" % true == { key = "test", val = true }


    open prelude
