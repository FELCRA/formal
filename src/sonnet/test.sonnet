

-- this is a comment

-- palette: →

    type X= Int
    type X = Int
    type X a= Int
    type X a = Int

    type F = Int->Int
    type F=Int->Int

    type G = Int -> Int -> Int

    type XXX = (Int -> Int)

   I'm a comment!

                          -> Int

-- These are some tricky type signatures to parse

    type G=(Int→Int)→(Int→Int)
    type G=(Int->Int) | Int
            | Str

    type H = { x : Int }
    type H = {x:Int,y:Str}

    type I = {x:Int}->{x:Int, y:Int}->(Int->{x:Int->Int,y:Int|Str})->Int

    type I = {x:Int}->{ x:Int, 
                        y:Int
             }
             ->(Int->{x:Int
                      ->Int,y:Int|Str})->Int

    type X m a = X a b c -> m d e
    type Y m a = Y a (m b) -> Y a {x: m a}

-- These are union types

    type R = Str | Int 
             | Int

    type Z = Int | Int -> Int | Str

-- These are some named types, with some sneaky whitespace errors (do not edit)

    type Q = true of {} | false of {}  
    
      
  
    type Option a = some of a | none of {} | any of Int -> Int | Str | none of {}   

-- These are some actual definitions

    x
     : Int 
     | = 1
    
    x : Int | = 1

    test: Int -> Int
        | x   = "test" 
        | y   = "fail"
        | z   = g 1 2 4 5 (3 + 5 + 7)

    xx: Str -> Int
      | x   = 1

    type X = Int

    yy: Int
      | "tes" = "test"
      | 1 = "fail"
      | true: = { x = 2 }
      | (true: 4) = 14
      | { x = 2 } = true:
      | [ 1,
          2, x] = f 4

--and some weird cases

      | x y = { x = x, y = "test" }


      | { x = { y = "test" }} = { z = 4, y = { x = {}}}

-- some infix expressions and labels

    zz: Int
      | x = monad: (\x = 3 | y = 4)
      | 2 = x ^ 3 + y ^ 2 / 2 + (3 - 4) < 2 + 4

    xxx: String
       | x = if test: (3 < x + 2) then "true" else "false"




